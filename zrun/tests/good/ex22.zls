(*
let node f x =
  forward(4) returns (o default 0)
    do o = 0 -> pre o + 1 until o = 42 done 
*)

(* produit de matrices *)

(*
let node f a b =
  forward(i < 4) ai in a, ri out r do
     forward(j < 5) rij out ri do
      forward(k < 6) bk in b, cpt init 0 do
        cpt = last cpt + a.(i).(k) * b.(k).(j)
      done
*)
   (*
let node f x =
  forward i < 4, ai in a returns ([ri] out r)
     do
        ri = forward (j < 5) returns (sum out ri)
                do
                   sum = forward (k < 6) returns (sum last 0)
                          do sum = last sum + ai.(k) * bk.(j) done
                done
     done
*)
(*
let node f x =
  forward i < 4, oi default 0 do
    do oi = 0 -> pre oi + 1 unless oi = 42 done
 *)

let node f x = foreach(4) do x done

let node f x =
  foreach(4) returns ([cpti init 0], [mi])
  local s do
    cpti = last cpti + x;
    mi = cpti + s;
    s = 0 fby mi + 1;
  done

let node f x =
  foreach(4), cpti init 0 out cpt, mi out m
  local s do
    cpti = last cpti + x;
    mi = cpti + s;
    s = 0 fby mi + 1;
  done

let node g x =
  let rec o =
    forward(4) do 
      let rec cpt = (0 fby cpt) + lo in
      cpt
    done
  and lo = 1 fby o in
  o

let node main4 () = g [| 1; 2; 3 |]

let node sum(xi, yi) = cpt where
  rec cpt = (0 fby cpt) + xi * yi

let node scalar (x, y) =
  forward(4) xi in x, yi in y do sum(xi, yi) done
  
let node main () =
  scalar (foreach(4) do 2 done, foreach(4) do 2 done)

let node plus1 x =
  foreach(4) xi in x do xi + 1 done

let node plus (x, y) =
  foreach(4) xi in x, yi in y do xi+yi done

let node plus11 x =
  foreach(4) xi in x do
    let rec cpt = xi fby cpt + 1 in cpt
  done

let node copy x =
  foreach(4) xi in x do
    let rec cpt = (0 fby cpt) + xi in
    cpt
  done
  
let node main () =
  plus (plus1 (f 0), plus1 (f 1))

let node main () =
  plus1 (copy (f 1))

let node main2() =
  plus11 (f 0)

let node main3 () =
  let x = f 0 in
  x.(0) default 42
