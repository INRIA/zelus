let node m1() returns (o)
  let r = 1 + 2 in
  let m = r + 2 in
  do o = 42 done

let node make(n)() = foreach(n) i in 0 to n-1 do i done

let node f x = x.(4 .. 5)

let node main0 () =
  let t = run (make(10))() in
  let v = f t in
  assert (v = [| 4; 5 |])
  
let node f () =
  forward(10) i in 0 to 9 returns (o init 0)
    do o = 0 -> pre o + i done

let node main1 () =
  let v = f () in
  v
    
let node f x =
  forward(4) returns (o default 0)
    do o = 0 -> (pre o + 1) done

let node main2 () =
  let v = f () in
  v

let node f x =
  forward(10) xi in x returns (o default 0)
    do o = (0 fby o) + xi done 

let node main3 () =
  let t = run (make(10))() in
  f t

let node f x = foreach(4) do x done

let node ff x =
  foreach(4) xi in x returns ([|cpti init 0|], [|mi|])
  local s do
    cpti = last cpti + x
  and
    mi = cpti + s
  and
    s = 0 fby mi + 1
  done

let node ff x = m where rec
  foreach(4) xi in x, m init 0 do
    foreach(4) xij in xi, m init last m do
      m = last m + xij
    done
  done

let node g x =
  let rec o =
    forward(4) do 
      let rec cpt = (0 fby cpt) + lo in
      cpt
    done
  and lo = 1 fby o in
  o

let node main4 () = g [| 1; 2; 3 |]

let node sum(xi, yi) = cpt where
  rec cpt = (0 fby cpt) + xi * yi

let node scalar (x, y) =
  forward(4) xi in x, yi in y do sum(xi, yi) done
   
let node main () =
  scalar (foreach(4) do 2 done, foreach(4) do 2 done)

let node plus1 x =
  foreach(4) xi in x do xi + 1 done

let node plus (x, y) =
  foreach(4) xi in x, yi in y do xi+yi done

let node plus11 x =
  foreach(4) xi in x do
    let rec cpt = xi fby cpt + 1 in cpt
  done

let node copy x =
  foreach(4) xi in x do
    let rec cpt = (0 fby cpt) + xi in
    cpt
  done
  
let node main5 () =
  plus (plus1 (f 0), plus1 (f 1))

let node main6 () =
  plus1 (copy (f 1))

let node main7() =
  plus11 (f 0)

let node main8 () =
  let x = f 0 in
  x.(0) default 42

(* sequential search in a array *)
let node find0 (x, a) returns (index, found)
  (index, found) =
    forward(5) i in 0 to 4, ai in a returns (index init 0, c init false)
      while not (last c) do index = i and c = (ai = x) done

let node main9 () =
  let v = find0 (3, [| 0; 1; 2; 3; 4 |]) in
  assert (v = (3, true))

let node find1 (x, a) returns (index, found)
  forward(5) i in 0 to 4, ai in a, index init 0, found init false
     while not (last found) do index = i and found = (ai = x) done

let node main10 () =
  let v = find1 (3, [| 0; 1; 2; 3; 4 |]) in
  assert (v = (3, true))


let node fill_up0 (max_i) returns (s)
    s = forward(5) i in 0 to 4 returns ([|a init 0|])
           while i < max_i do a = i done

let node main11 () =
    let v = fill_up0 (2) in
  assert (v = [|0;1;1;1;1|])

let node fill_up1 (max_i) returns (s)
    forward(5) i in 0 to 4, si init 0 out s
           while i < max_i do si = i done

let node main12 () =
  let v = fill_up1 (2) in
  assert (v = [|0;1;1;1;1|])


let node scalar_10 (x, y) returns (o)
    forward(10) xi in x, yi in y, o init 0
      do o = last o + xi * yi done

let node scalar_n n (x, y) returns (o)
    forward(n) xi in x, yi in y, o init 0
      do o = last o + xi * yi done

let node main13 () =
  let v1 = foreach(10) i in 0 to 9 do i done in
  let v2 = foreach(10) i in 0 to 9 do i done in
  let v = run (scalar_n (10)) (v1, v2) in
  assert (v = scalar_10 (v1, v2))

(* Cholesky. [a] is a [n x n] definite positive matrix. [l] is a *)
(* triangular matrix such that [l * (transpose l) = a] *)
(* not very elegant. Repetitions. Not efficient because [n x n] steps *)
(* instead of [n x n-1 / 2] *)
let mat = fun (n,v) -> fun () =>
  foreach i in 0 to n-1 do foreach i in 0 to n-1 do v done done

let node main14() = run (mat(5, 0.0))()

(* cholesky *)
let node cholesky_exp(n)(a) returns (l)
  do l =
   forward i in 0 to n-1, ai in a returns (l init run (mat(n, 0.0)) ())
     do l = forward j in 0 to n-1, aij in ai returns (l init last l)
              do
                let tmp_sum =
                  forward k in 0 to i-1 returns (cpt init 0.0)
                    do cpt = last cpt +. (last l).(i).(k) *. (last l).(j).(k)
                    done in
                let lij = if i = j then sqrt(aij -. tmp_sum)
                          else if j < i then
		                 (aij -. tmp_sum) /. (last l).(j).(j)
		               else 0.0 in
                do l = [| last l with i, j <- lij |] done
	      done
     done
  done

(* in equational form *)
let node cholesky(n)(a) returns (l)
  forward i in 0 to n-1, ai in a, l init run (mat(n, 0.0))() do
    forward j in 0 to n-1, aij in ai, l init last l do
      let tmp_sum =
            forward k in 0 to i-1 returns (cpt init 0.0)
               do cpt = last cpt +. (last l).(i).(k) *. (last l).(j).(k)
               done in
      let lij = if i = j then sqrt(aij -. tmp_sum)
                else if j < i then (aij -. tmp_sum) /. (last l).(j).(j)
                else 0.0 in
      do l = [| last l with i, j <- lij |] done
    done
  done

let node main15() =
  let m = [| [| 1.0; 2.0; 4.0 |];
	     [| 2.0; 3.0; 5.0 |];
	     [| 4.0; 5.0; 6.0 |] |] in
  run (cholesky(3))(m)

let node main16() =
  let m = [| [| 1.0; 0.0; 0.0 |];
	     [| 0.0; 1.0; 0.0 |];
	     [| 0.0; 0.0; 1.0 |] |] in
  run (cholesky(3))(m)

(*
m2 = numpy.array ([[4.0, 12.0, -16.0],
                  [12.0, 37.0, -43.0], 
                  [-16.0, -43.0, 98.0]])
>>> numpy.linalg.cholesky(m2)
array([[ 2.,  0.,  0.],
       [ 6.,  1.,  0.],
       [-8.,  5.,  3.]]) *)
    
let node main17() =
  let m = [| [|4.0; 12.0; -16.0 |];
	     [| 12.0; 37.0; -43.0 |];
	     [| -16.0; -43.0; 98.0 |] |] in
  let m_result = run (cholesky(3))(m) in
  let m_expected =
    [| [| 2.;  0.;  0. |];
       [| 6.;  1.;  0. |];
       [| -8.;  5.;  3. |] |] in
  assert (m_result = m_expected)

let node main18() =
  let m = [| [|4.0; 12.0; -16.0 |];
	     [| 12.0; 37.0; -43.0 |];
	     [| -16.0; -43.0; 98.0 |] |] in
  let m_result = run (cholesky_exp(3))(m) in
  let m_expected =
    [| [| 2.;  0.;  0. |];
       [| 6.;  1.;  0. |];
       [| -8.;  5.;  3. |] |] in
  assert (m_result = m_expected)

(*
One like to write:

forward i in 0 to n-1, ai in a,
        j in 0 to n-1, aij in ai, l init mat(n, 0.0)
    do
     ...
    done

instead of:

forward i in 0 to n-1, ai in a, l init mat(n, 0.0) do
    forward j in 0 to n-1, aij in ai, l init last l do
      
let cholesky <<n>> (a:[n,n]float) = (l:[n,n]float)
  forward i in 0 to n-1, ai in a, l init [n,n]0 do
    forward j in 0 to n-1, aij in Ai, l init last l do
      if  j < i then
	l = [| last l with [i,j] = (aij -. vec_vec (l.(i).(j)) / a.(j).(j) |]
      else
	if j = i then
	  l = [| last l with [i,j] = sqrt (aij - vec_vec (l.(i),l.(j)) |]
        else l = last l
    done
  done
	    *)
      
(*
let node cholesky(a) returns (l)
    forward i in 0 to n, ai in a, li out l do
      forward k in 0 to i + 1, lik out li
        let tmp_sum = scalar((last l).(i), (last l).(k)) in
        do if i = k then
	     lik = sqrt(ai.(i) - tmp_sum)
	   else
	     lik = (1.0 /. (last l).(k) *. (ai.(k) - tmp_sum))
	done
*)	       
