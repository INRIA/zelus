let node incr(x) returns (o)
    o = 0 fby x + 1

let node nat () =
  let rec o = incr o in o, 0
    
let node fibo () returns (o)
  local po
  do po = 1 fby (po + o)
  and o = 1 fby po done

let node euler_forward(h, x0, xprime) returns (x)
  x = x0 -> pre(x +. h *. xprime)

let node euler_backward(h, x0, xprime) returns (x)
    x = x0 -> pre(x) +. h *. xprime

(* [ (x(n+1) - x(n)) / h = f x(n) *)
let node main45() returns (x)
  x = euler_forward(0.1, 1.0, 0.5 *. x)

let node sum(x) returns (o)
  o = forward xi in x
        do let rec o = (0.0 fby o) +. xi in o done

let node sum(x) returns (o)
  forward xi in x, o init 0.0
     do o = last o +. xi done

let node sum(x, y) = o where
  rec v = x *. y and o = (0.0 fby o) +. v

let node scalar(t1, t2) =
  forward xi in t1, yi in t2 do
    sum(xi, yi)
  done

    
let node main42() =
  scalar([|1.0; 2.0; 3.0|] fby [|2.0; 3.0 fby 42.0; 4.0|],
	 [|1.0; 2.0; 3.0 |])
      
let g = 42

let node from(x') = o where
  rec o = 1 -> pre(o + x')

let node main() =
  let rec o = from(o) in o
    
let node f(x, y) returns (o)
  local z
  do o = x + y
  and z = x + 1
  done

let node g(x, y) returns (o)
  o = let rec z = x + 1 and o = x + y in o

let node main1() returns (m)
  m = f(1, 2)

let node main2() returns (m)
    m = g(1, 2)

let node f(x) = 0 fby x + 1

let node g() = 1, 2

let node h() returns (y)
  y = f(y)

let node main3() returns (o)
  do o = h () done
      
let node g() returns (y, z)
  do y = run f(z) and z = y done
    
let node main4() returns (o)
  local o1, o2, o3, z
  do  o1, o2 = run g() and o3 = (0 fby z) + 1 and z = o3
  and o = (o1 = o3) && (o2 = z) done
      
let node main5() returns ()
  local m1 default 0, m2, half, o
  do
    if half then do done
    else do m1 = 42 -> pre m1 + 1 done
  and
    if half then do m2 = 0 done
    else do m2 = 42 -> pre m2 + 1 done
  and
      half = true -> not (pre half)
  and
      o = m1 = m2
  and
      assert o
  done
 
