(* for loops in equational form *)
 let node f() returns (r)
  forward(3) i in 0 to 2, ri out r do
   forward(5) j in 0 to 4, ri init 0 while ri < 2 do
      ri = last ri + 1
     done
   done

let node main1() = f()

let node f() returns (ri)
  forward(3) i in 0 to 2, ri init 0 do
   forward(5) j in 0 to 4, ri init last ri do
      ri = last ri + 1
     done
   done

let node main2() =
   assert (f() = 15)
   
(* scalar product in equational form *)
let node scalar_eq (x, y) = m where
  rec forward(4) i in 0 to 3, m init 0
        do m = last m + x.(i) * y.(i) done

let node main3 () =
  let v1 = [|1; 2; 3; 4|] in
  let v2 = [|1; 2; 3; 4|] in
  assert (scalar_eq (v1, v2) = 30)

let node sum_eq1 (x) returns (m)
  forward(4) xi in x, m init 0
    do m = last m + xi done

let node main4() =
  let v = [|1; 2; 3; 4|] in
  assert (sum_eq1 v = 10)
    
let node sum_eq2 (x) = m where
  rec forward(4) i in 0 to 3, m init 0
    do m = last m + x.(i) done

let node main5() =
  let v = [|1; 2; 3; 4|] in
  assert (sum_eq1 v = 10 && sum_eq2 v = 10)

(* sum of the elements of a two dimension array - equational form *)
let node sum_eq m returns (o')
    forward(3) mi in m, o' init 0 do
      forward(4) mij in mi, o' init last o'
         do o' = last o' + mij done
      done

let node main6() =
  let m = [| [|1; 2; 3; 4|];
	     [|5; 6; 7; 8 |];
	     [|9; 10; 11; 12|] |] in
  assert (sum_eq m = (12 * 13)/2)


(* matrix product in equational form *)
let node prod_matrix0(l)(m)(n)(a_l_m, b_m_n) = r where rec
  forward(l) i in 0 to l-1, ai in a_l_m, ri out r do
     forward(n) j in 0 to n-1, rij out ri do
      forward(m) k in 0 to m-1, bk in b_m_n, rij init 0 do
        rij = last rij + ai.(k) * bk.(j)
      done
     done
  done


let node main7 () =
  let m1 = [| [| 1; 2; 3; 4 |];
	      [| 5; 6; 7; 8 |];
	      [| 9; 10; 11; 12 |] |] in
  let id = [| [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1|] |] in
  run (prod_matrix0(3)(4)(5))(m1, id)
 
(* the same with a return *)
let node prod_matrix1(a_3_4, b_4_5) returns (r)
  forward(3) i in 0 to 2, ai in a_3_4, ri out r do
     forward(5) j in 0 to 4, rij out ri do
      forward(4) k in 0 to 3, bk in b_4_5, rij init 0 do
        rij = last rij + ai.(k) * bk.(j)
      done
     done
  done

	  
let node main8 () =
  let m1 = [| [| 1; 2; 3; 4 |];
	      [| 5; 6; 7; 8 |];
	      [| 9; 10; 11; 12 |] |] in
  let id = [| [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1 |];
	      [| 1; 1; 1; 1; 1|] |] in
  assert (run (prod_matrix0(3)(4)(5))(m1, id) = prod_matrix1(m1, id))
    

(*let f{a,b,c}(x, y, z) =
    forall{a} xi in x do xi + 1 done,
    forall{b} yi in y do yi + 1 done,
    forall{c} zi in z do zi + 1 done

val f : 'a 'b 'c . int['a] * int['b] * int['c] -> int['a] * int['b] * int['c] *)
