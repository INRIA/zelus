(* dune exec -- zeluc t0.zls *)
let fix f x = let rec y = f x y in y

let const map__ <<n>> f x y = forward(n) (xi in x, yi in y) returns ([|zi|])
                                 do zi = f xi yi done


let const f_00<<n>>(x:[n]int, y:[n]int) =
  let x = x ++ [|1;2|] in
  let y = y ++ [|2;3|] in
  map__ <<n+2>> (fun x y -> x + y) x y 

type t1 =
 | Zero | Constant of float | Linear of float

let node simpl_chunk (dur, typ) =
   match typ with
   | Zero -> None
   | Constant v -> let new_c = (dur, Zero) in Some new_c
   | Linear v -> let new_c = (dur, Constant v) in Some new_c


let fix2 f g x = let rec y = f x z and z = g x y in y, z


type t2 = P of int * int

let node ff(x) = o where
  match x with
  | P(v1, v2) -> do o = 1 -> last v1 + v2 done
  end

let node f(x) =
  match x with
  | P(v1, v2) -> 1 -> last v1 + v2
  end
    
let node g(x) =
  present x(v1, v2) -> 1 -> last v1 + v2
    
let node gg(x) = o where
  init o = 0
  and
    present x(v1, v2) -> do o = 1 -> last v1 + v2 done

let node one (o1, o2) = o where
  o = present o1(x) | o2(x) -> x + x init 42
      
let node two x = o where
  rec o = 1 -> pre o + pre o + x

let node double_two x =
  two (x+1) + two (x+2) + (0 fby x)
    
let hybrid gh(z) =
  let rec init x = 0
  and present z -> do x = 1 done
  and present (disc(last x)) -> do () = print_int x done in
  x

let node f0(x) returns (y)
  y = last y + x
  
let const node f1<<n>>(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = xi + 1 done

let node f1'(x) returns (y)
  y = forward (42) (xi in x) returns ([|yi|])
        do yi = xi + 1 done

(* let const rec buffer<<n>> = node x ->
    match n with
    | 0 -> x | _ -> x fby (run (buffer<<n>>)(x))

let rec xor =  fun n x ->
    match n with
    | 0 -> true
    | _ -> let x1++x2 = x in (xor_ <n/2> (x1)) xor (xor_ <n/2> (x2))

           (xor_ <n/2> x.[0..n/2-1])) xor (xor_ <n/2> (x.(n/2..n-1))) *)

(* map : (a1 -> a2) -> [n1]a1 -> [n2]a2 *)
let const map<<n>> (* f : (_ -> _) -> ([_]_ -> [_]_) *) =
  node f (x:[n]'a) -> forward(n) (xi in x) returns ([|yi|])
               do yi = run f xi done
	       
let const node f2<<n>>(x, z) returns (y)
  forward(n) (xi in x) returns (yi out y)
    local k in
    do yi = xi + 1 and k = 42 until z = 0 done

let node f3(x, z) returns (y)
  forward(43) (i in 0 to 42, xi in x) returns (yi out y)
    local k in
    do yi = xi + 1 and k = last k + 1 unless z = 0 done

let node f4(x, z) returns (y)
  forward(42) (xi in x) returns (yi out y)
    local k in
    do yi = xi + 1 and k = yi while z = 0 done

let node f5 y (x, z) returns (t)
  local m in
  forward(42) (xi in x) returns (m, ti out t)
    local k in
    do m = 1 and ti = xi + 1 and k = ti while z = 0 done

let node f5' (x, y) = f5 42 (x, y)

let const node f5'' (const y) (const m) (x, z) = y + x + z

let node f6(x:[41+1]int, z) returns (y)
  local m in
  forward(42) (xi in x.R) returns (m, yi out y)
    local k in
    do m = 1 and yi = xi + 1 and k = 0 while z = 0 done


let node f7(f)(x) returns (y)
  local m in
  foreach(42) [i] (xi in x) returns (m, yi out y)
    local k in
    do m = xi and yi = f(xi) + i and k = 0 done

let const f8 = fun x -> node x -> x + 1

let const f9<<a>>(x) = x + 1

let const node f10<<a>>(x) = x + 1

let const f10'<<a,b>> = node x -> x + 1

let const f11<<a,b,c>> = node (x, y) returns (z)
  forward(42) [i] (xi in x, yi in y) returns (zi out z)
    do forward(32) [j] (xij in xi, yij in yi) returns (zij out zi)
       do zij = xij + yij + x.(i).(j) done
    done
      
let const node f12<<a>>(x, y) returns (z)
  z = f11<<a+1,a, a>>(x, y)

 
let const fff<<a,b>>(x:[a]int, y:[b]int) = x ++ y
