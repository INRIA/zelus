let node f n x = n -> pre(x) + 1

let node compose f g x = run f(run g(x+x))
   
let node higher f g x y = run (f g) (x+y+1)

let node f3 n x = f 1 (x+3)
    

let node f1(x) = 0 -> pre x + 1
let node f2(x) = x + 2

let node h g x = g(x+1) + g(x+2)

let node boucle<<n>>(x:[n]'a) = 
  local o
  do forward[i](x_i in x) returns (o_i out o) do
       o_i = f1(x_i) + i
     done in
  o

let static add(x, y) = x + y

let node main1(x) = f(1+2)(x)

let node main(x, t) =
  let r = (compose f1 f2)(x + 1) + f1(x+2) + f1(x+3)
      + (higher f3 f1) (1+4) (5+x) + (f (add(1, 2)))(x) in
  (boucle<<42 + 1>>(t)).(2) + r + main1(x)

let node map<<n>>(const f)(t:[n]'a) = t' where
  rec forward (t_i in t) returns (t'_i out t')
	do t'_i = run f t_i done

let const node g x = x + x

let node map_g(t) = map<<42+2>>(g)(t)
    
let f42<<n>> (t1:[n]'a) = t where rec
  forward[i](t_i in t1) returns (ti out t, x init 0) do
    ti = t_i + 1 and x = 2
  done
	

let sum_array<<n>> (t1:[n]'a, t2:[n]'a) returns (t)
  forward[i](x in t1, y in t2) returns (z out t) do
      z = x + y 
  done

let sum_array2 t = sum_array<<42+42>>(t, t)

let node loop<<n>> () =
  forward(n)[i] returns (m init 0) do m = last m + 1 done

let node loop_42 () = loop<<42>> () + loop<<43>> ()

let scalar<<n>> (t1:[n]'a, t2:[n]'a) =
  forward[i](x in t1, y in t2) returns (o init 0)
    do o = last o + x * y done
    
let transpose<<n,m>>(m1 : [n][m]'a) returns (m2)
 forward(m)[i]() returns (m2_i out m2) 
   do forward(n)[j]() returns (m2_i_j out m2_i)
        do m2_i_j = m1.(j).(i) done
   done
   
let sum_matrix<<n,m>>(m1:[n][m]'a, m2:[n][m]'a) = (m3) where rec
    forward(m1_i in m1, m2_i in m2) returns (m3_i out m3)
      do forward(m1_i_j in m1_i, m2_i_j in m2_i) returns (m3_i_j out m3_i)
	   do m3_i_j = m1_i_j + m2_i_j done
      done

