let f1 x =
  let h = 1 and g = inline fun x -> x + 1 in
  g 1 + g 2


let node f2 x =
    let inline app f x = f x in
    let inline f x = x + 1 in
    let node g x = app f x in
    g (1+2), g (1+3)

let node f3 x =
  let inline node f x = x + 1 in
  run f (x+1)

let node controller h (p, i, d) u =
  let inline node prop h u = u in

  let inline node int h u =
    let rec o = 0.0 -> pre o +. h *. u in o in

  let inline node derivative h u = 0.0 -> (u -. pre(u)) /. h in

  let inline node pid h prop int derivative (p, i, d) u =
   run (int h)(i *. u) +. run (derivative h)(d *. u) +. run (prop h)(u) in

  pid h prop int derivative (p, i, d) u

 
(*
let node f() returns (o init 0)
  automaton
  | Up ->
     local cpt in
     do cpt = (0 fby cpt) + 1
     and o = last o + cpt until (o >= 10) then Down
  | Down ->
     do o = last o - 1 until (o <= 1) then Up
  end
*)

(*
let node f2() returns (o init 0)
  automaton
  | Up ->
     let rec cpt = (0 fby cpt) + 1 in
     do o = last o + cpt until (o >= 10) then Down
  | Down ->
     do o = last o - 1 until (o <= 1) then Up
  end

let node ff() =
  print_int (f ());
  print_newline ()
*)

(*
let hybrid f x = 1.0

let hybrid g () = f (0.0)
*)

(* horizon m = 2.0 up x = ...

horizon m = 1.0 *)

(* let f_4 =
    hybrid  (major_6, time_7) 
       ->
         local m_5, init_10, h_8, z_9
         do init init_10 = true 
         and reset  init h_8 = time_7 +. 0.100000 every last init_10
	 and init_10  = false
	 and z_9 = Stdlib.(&&) major_6 (Stdlib.(>=) time_7 last* h_8)
	 and h_8 = if z_9 then Stdlib.(+.) last* h_8 2.000000 else
                     last* h_8
         and m_5 = z_9 in 
         m_5 *)
	 
(* globally defined name *)

(*
let hybrid f() =
  let m = period(0.1|2.0) in
  m

let g = 9.81
*)

(*
let const f = 1
let g = let const r = f in 2+r
*)

(*
let node cond_act1 (c) = 
 local x, y do
  init x = 0 and init y = 0
  and if c then
         do x = y + 1 done
      else
         do y = x + 1 done
  in
 x, y

let node cond_act2 (c) = 
 let rec init x = 0 and init y = 0
     and if c then
         do x = y + 1 done
      else
         do y = x + 1 done in
 x, y


let g = 9.81

let hybrid ball() =
  let rec der y = y' init 10.0
  and der y' = -. g init 0.0 reset z -> 0.8 *. last y'
  and z = up(-. y) in
  let o = present z -> 1.0 else 0.0 in
  ()



let node from n returns m
  m = 0 fby (let rec p = 1 fby (m+p) in p)

let node main() =
  let o = from 0 in
  print_int o; print_newline ()
*)


(*
let node h x =
  let rec init o = 1 and o = last o + 1 in last o (* + last x *)

let node hh x =
  local x do x = last x + 1 and init x = 0 in last x + 1
*)

(*
let node h x =
  let rec init o = 1 and o = last o + 1 in last o (* + last x *)

let node hh x =
  local x do x = last x + 1 and init x = 0 in last x + 1
*)


(*
let node j x =
  let rec o = 0 fby x + 1
  and z = 1 fby o
  and k = z + 2 in k + o

let node jj x = j(x+1) + j(x+2)

let node main () =
  let nat = 0 in
  let o = jj nat in
  print_int o; print_newline ()
*)
