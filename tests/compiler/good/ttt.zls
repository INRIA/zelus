let f0<<n>>(x) = forward(n)(xi in x) returns ([|oi|])
                   do oi = xi + 1 done

let rec f1<<n>>(x) = match size n with | 0 -> x | m -> f1<<m-1>>(x) + x

let f2<<n>>(x:[n]'a) =
  forward(n)[i]() returns ([|oi|])
    do oi = forward(n)[j]() returns ([|oi|])
             do oi = x.(i) + x.(n - 1 - j) done
    done
    
let f3(x) = f2<<42>>(x)

let j() =
  forward(42)[i]() returns (oi)
   do oi = f1<<42>>(0) done

(* n et i sont des tailles. n est une taille statique; i est une taille bornee *)

let f<<n,i>>(x:[n]'a) = x.(i)

(* let f<<n>>[i](x:[n]'a) = x.(i) *)
(* let f<<n,m>>[i][j](x) = x.(i).(j) *)

(* let f<<i:n,j:m>>(x:[n]a) = x.(i).(j) *)

(* f<<i:n,j:m>>(y) *)
(* let f<<n:[i]>>(x) = x.(i) *) 
(* let f<<n>>(i:[n])(x:[n]'a) = x.(i) *)
(* Pour les tailles, il y a deux sortes: constante ou bornee. *)

let h<<n>>(x:[42]'a) =
  forward(42)[i]() returns (oi)
    do oi = f<<42,41>>(x)  done

(* f : <<n,i0>>.[n]'a -> 'a with i0 < n *)
(* f<<i,i+2>>: [i]'a -> 'a with let n = i and i0 = i+2 in i0 < n *)
(* x : [42]a. Donc on ajoute (i = 42) && (let n = i and i0 = i+2 in i0 < n *)

let g<<n>>(x:[n]'a) =
  forward(n)[i]() returns (oi)
    do oi = f<<n,52>>(x) done

let main() = g<<2>>[|1;2|]

(* verifier le typage des tailles car ce programme ne devrait pas etre accepte *)
(* i+2 doit etre < i *)
