(* Examples about the Hack processor - book Nand2Tetris *)
(* and some others *)

(* dichotomy search in an array *)
let rec dicho<<n>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2>>(v, x.(0 .. n/2 - 1))
           | _ -> dicho<<n-n/2-1>>(v, x.(n/2 + 1 .. n-1))

let main___1(x: [5]int) = dicho<<5>>(0, x)

let dicho_without_slices<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i>>(v, x:[m]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i>>(v, x)
           | _ -> dicho<<n/2,i+n/2>>(v, x) in
  dicho<<m,0>>(v, x)

let main___2(x) = dicho_without_slices<<42>>(0, x)

(* or n-way (linear) *)
let rec or_n<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(0) or or_n<<n-1>>(x.(1 .. n-1))

let or_n_linear_42(x) = or_n<<42>>(x)

(* or n-way (log) *)
let rec or_log<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | 1 -> y = x.(0)
    | _ -> y = or_log<<n/2>>(x.(0 .. n/2 - 1)) or
               or_log<<n-n/2>>(x.(n/2 .. n-1))

let or_n_log_42(x) = or_log<<42>>(x)

(* adders *)
let half_adder(a, b) returns (s, carry)
  do s = if a then not b else b
  and carry = a && b
  done
  
let xor(a, b) = if a then not b else b

let adder(a, b, c) returns (s, carry)
  local s1, c1, c2
  do s1, c1 = half_adder(a, b)
  and s, c2 = half_adder(c1, c)
  and carry = c1 or c2
  done
  
let full_adder(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = (a && b) or (b && c) or (a && c)
  done

(* n-bit adder *)
let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  match size n with
  | 0 -> o = [||]
  | _ -> let s, carry = full_adder(x.(0), y.(0), c) in
         o  = [|s|] ++
	      (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

(* address decoder - address multiplexer *)
let decoder_simple(sel, adr) returns (s0, s1)
  do
     s0 = sel && not adr
  and
     s1 = sel && adr
  done
  
let rec decoder<<n,k>>(sel: bool, adr: [n]bool)
returns (s: [k]bool)
  local s0, s1 
  do
    (s0, s1) = decoder_simple(sel, adr.(n-1))
  and
    match size n with
    | 1 -> do s = [|s0; s1|] done
    | _ -> do s = decoder<<n-1, k/2>>(s0, adr.(0 .. n-2)) ++
                  decoder<<n-1, k/2>>(s1, adr.(0 .. n-2)) done
  done

let decoder_2(adr: [2]bool) returns (s: [4]bool)
  s = decoder<<2,4>>(true, adr)

(*
-- multiplexer
-- inverse of a decoder.
-- input: 2^n bits and a n-bits address
-- output: choose the n-th input
*)
let multiplexer_simple(a0, b0, b1) returns (s)
  s = if a0 then b1 else b0

let multiplexer_double(a0, a1, b0, b1, b2, b3) returns (s)
  local s0, s1, s2, s3 in
  do
   s = s0 or s1 or s2 or s3
  and
   s0 = b3 && a0 && a1
  and
   s1 = b2 && a1 && not a0
  and
   s2 = b1 && not a1 && a0
  and
   s3 = b0 && not a1 && not a0
  done

let rec multiplexer_n<<n,k>>(a: [n]bool, b: [k]bool)
returns (s:bool)
  local s0, s1 in
  do
   match size n with
   | 1 -> do s0, s1 = b.(0), b.(1) done
   | _ -> do s0, s1 =
            multiplexer_n<<n-1,k/2>>
	      (a.(0 .. n-2), b.(0 .. k/2 - 1)),
            multiplexer_n<<n-1, k/2>>
	      (a.(0 .. n-2), b.(k/2 .. k - 1)) done
  and
   s = multiplexer_simple(a.(n-1), s0, s1)
  done

let multiplexer_2(a: [4]bool, b: [16]bool) returns (s: bool)
  s = multiplexer_n<<4,16>>(a, b)

