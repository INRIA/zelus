(* Examples about the Hack processor - book Nand2Tetris *)
(* and some others *)

let nand (a, b) returns (out_)
  out_ = not (a && b)

let xor_ (a, b) returns (out_)
  out_ = if a then not b else b

let mux (a, b, sel) returns (out_)
  out_ = if sel then b else a

let dmux (in_, sel) returns (a, b)
  a, b = if sel then (false, in_) else (in_, false)

let check_mux_dmux (x, sel) returns (o)
  let a, b = dmux(x, sel) in
  do o = (x = mux(a, b, sel)) done

let andMuxOr(sel, a, b: bool) returns (out_: bool)
  out_ = if sel then a or b else a && b

let dmux4(in_, a1, a0) returns (s0, s1, s2, s3)
  (s0, s1, s2, s3) =
    if a0 then if a1 then (false, false, false, in_)
               else (false, in_, false, false)
    else if a1 then (false, false, in_, false)
         else (in_, false, false, false)

(* section 1.2.3 *)

let lift1 <<n>> (const f) (x) =
  let rec lift_rec <<n>> (x:[n]bool) returns (o:[n]bool)
    match size n with
    | 0 -> o = [||]
    | n -> o = [| f x.(0) |] ++ (lift_rec <<n-1>> (x.(1 .. n-1))) in
  lift_rec <<n>> (x)

let lift2 <<n>> (const f) (x, y) =
  let rec lift_rec <<n>> (x:[n]bool, y:[n]bool) returns (o:[n]bool)
    match size n with
    | 0 -> o = [||]
    | n -> o = [| f x.(0) y.(0) |] ++
               (lift_rec <<n-1>> (x.(1 .. n-1), y.(1 .. n-1))) in
  lift_rec <<n>> (x, y)

(* or with a for loop *)
let lift_loop1 <<n>> (const f) (x:[n]bool) =
  foreach(n)(xi in x) returns ([|yi|])
    do yi = f xi done

let lift_loop2 <<n>> (const f) (x, y:[n]bool) =
  let rec lift_rec <<n>> (x:[n]bool, y:[n]bool) returns (o:[n]bool)
    match size n with
    | 0 -> o = [||]
    | n -> o = [| f (x.(0)) (y.(0)) |] ++
               (lift_rec <<n-1>> (x.(1 .. n-1), y.(1 .. n-1))) in
  lift_rec <<n>> (x, y)

let not16 (x) = lift1<<16>> (fun x -> not x) x
let and16(x, y) = lift2<<16>> (fun x y -> x && y) (x, y)
let or16(x,y) = lift2<<16>> (fun x y -> x or y) (x, y)
let eq16(x,y) = lift2<<16>> (fun x y -> x = y) (x, y)

(* or n-way (linear) *)
let rec or_n_way_linear<<n>>(x:[n]'a) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(0) or or_n_way_linear<<n-1>>(x.(1 .. n-1))

let or_n_way_linear16(x) = or_n_way_linear<<16>>(x)

(* or n-way (log) *)
let rec or_n_way<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | 1 -> y = x.(0)
    | _ -> y = or_n_way<<n/2>>(x.(0 .. n/2 - 1)) or
               or_n_way<<n-n/2>>(x.(n/2 .. n-1))

let or_n_way16(x) = or_n_way<<16>>(x)

let rec and_n_way<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | 1 -> y = x.(0)
    | _ -> y = and_n_way<<n/2>>(x.(0 .. n/2 - 1)) &&
               and_n_way<<n-n/2>>(x.(n/2 .. n-1))

let and_n_way16(x) = and_n_way<<16>>(x)

(*
Chapter 2: Boolean Arithmetic
=============================
http://www1.idc.ac.il/tecs/book/chapter%2002.pdf
section 2.2.1
*)

(* warning: the following example does not type check. The typing *)
(* is more difficult because the types [ti] of every branches are different *)
(* the type system must find a more general type [t] such that [t[n/i] = ti] *)

(* let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  o = match size n with
  | 0 -> [||]
  | _ -> let s, carry = true, true in
         [|s|] ++ (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

let add_2(x:[42]bool, y:[42]bool) returns (o:[42]bool)
  o = add_n<<42>>(x, y, false)
*)

let xor(a, b) = if a then not b else b

(* adders *)
let half_adder(a, b) returns (s, carry)
  do s = xor(a, b)
  and carry = a && b
  done
  
let full_adder(a, b, c) returns (s, carry)
  local s1, c1, c2
  do (s1, c1) = half_adder(a, b)
  and (s, c2) = half_adder(c1, c)
  and carry = c1 or c2
  done
  
let adder_reference(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = (a && b) or (b && c) or (a && c)
  done

let adder_reference_2(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = if a then b or c else b && c
  done

let add_equivalence(a, b, c: bool) returns (ok: bool)
  local sum1, carry1, sum2, carry2: bool
  do
     (sum1, carry1) = full_adder(a, b, c)
  and
     (sum2, carry2) = adder_reference(a, b, c)
  and
     ok = (sum1 = sum2) && (carry1 = carry2)
  done

(* n-bit adder *)
let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  match size n with
  | 0 -> o = [||]
  | _ -> let s, carry = full_adder(x.(0), y.(0), c) in
         o  = [|s|] ++
	      (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

(* build a constant array by repeating a value [v] *)
let rec make<<n>>(v) returns (o:[n]'a)
  match size n with
  | 0 -> do o = [||] done
  | _ -> do o = [|v|] ++ make<<n-1>>(v) done

let rec make_2<<n>>(v) = forward(n) returns ([|vi|]) do vi = v done

let inc_n<<n>>(x: [n]bool) returns (o: [n]bool)
  o = add_n<<n>>(x, make<<n>>(false), true)

let not_n<<n>>(x: [n]bool) returns (o: [n]bool)
  foreach(n) (xi in x) returns (oi out o)
    do oi = not xi done
    
let add16 (x : [16]bool, y : [16]bool) returns (o: [16]bool)
  o = add_n<<16>>(x, y, false)

let inc16 (x : [16]bool) returns (o: [16]bool)
  o = inc_n<<16>>(x)

(* question: show that -x = not(x) + 1 *)

let minus_one_n<<n>>(x: [n]bool) returns (mx: [n]bool)
  mx = inc_n<<n>>(not_n<<n>>(x))

(* Checks that all bit are 0 *)
let zero_n<<n>>(x: [n]bool) returns (o: bool)
  o = not(or_n_way<<n>>(x))

let zero4(x: [4]bool) returns (o: bool)
  o = zero_n<<4>>(x)

let minus_correct_n<<n>>(x: [n]bool) returns (ok: bool)
  ok = zero_n<<n>>(add_n<<n>>(x, minus_one_n<<n>>(x), false))

let minus_correct4(x: [4]bool) returns (ok: bool)
  ok = minus_correct_n<<4>>(x)

(* section 2.2.2 *)
let alu (in_x, in_y: [16]bool, (* Two 16-bits data inputs *)
          zx, (* Zero the x input *)
          nx, (* Negate the x input *)
          zy, (* Zero the y input *)
          ny, (* Negate the y input *)
          f,  (* Function code:  1 for Add,  0 for And *)
          no  (* Negate the out output *)
          : bool)
returns (out_: [16]bool,
         zr,  (* True iff out=0 *)
         ng   (* True iff out<0 *)
         : bool)
 local x, y, x_aux, y_aux, out_aux: [16]bool
 do   x_aux = if zx then make<<16>>(false) else in_x
 and  x = if nx then not16 (x_aux) else x_aux
 and  y_aux = if zy then make<<16>>(false) else in_y
 and  y = if ny then not16 (y_aux) else y_aux
 and  out_aux = if f then add16 (x, y) else and16 (x, y)
 and  out_ = if no then not16 (out_aux) else out_aux
 and  zr = not (or_n_way16 (out_))
 and  ng = out_.(15)
 done


(* Chapter 3: Sequential Logic
===========================
http://www1.idc.ac.il/tecs/book/chapter%2003.pdf
section 3.2.1 *)

let node dff (x) returns (y)
  y = false -> pre x

let node dff_n<<n>>(x:[n]bool) returns (y:[n]bool)
  foreach(n) (xi in x) returns (yi out y)
    do yi = false -> pre xi done

let node dff16(x) = dff_n<<16>>(x)

(* section 3.2.2 *)

let node bit (in_, load) returns (out_)
  out_ = dff(mux(out_, in_, load))

let rec node register_n<<n>>(in_: [n]bool, load: bool) returns (out_: [n]bool)
  match size n with
  | 0 -> out_ = [||]
  | n -> out_ = [| bit(in_.(0), load) |] ++
                (register_n<<n-1>>(in_.(1 .. n-1), load))

let node register16 (in_, load) returns (out_)
  out_ = register_n<<16>>(in_, load)

let node register_n_2<<n>>(in_: [n]bool, load: bool) returns (out_: [n]bool)
  out_ = (make<<n>>(false)) -> pre(if load then in_ else out_)

let node register_2 (in_, load) returns (out_)
  out_ = register_n_2<<16>>(in_, load)


(* section 3.2.4 *)
let node pc_model_spec (in_, inc, load, res) returns (out_)
 local pout
 do out_ = (make<<16>>(false)) -> if pre res then make<<16>>(false)
                                  else
                                   if pre load then pre in_
                                   else
                                    if pre inc then inc16 (pout)
                                    else pout
 and pout = pre out_
done

let mux16(b_true, b_false, cond) = mux(b_true, b_false, cond)

let node pc_model (in_, inc, load, res) returns (out_)
  out_ = dff16(mux16(mux16(mux16(out_, inc16(out_), inc), in_, load),
                     make<<16>>(false), res))


let node check_pc_model_spec(in_: [16]bool, inc, load, res) returns (ok)
  ok = and_n_way16(eq16(pc_model_spec(in_, inc, load, res),
                        pc_model(in_, inc, load, res)))


(* Chapter 5: Computer Architecture
================================
http://www1.idc.ac.il/tecs/book/chapter%2005.pdf
section 5.2.2 *)

let node cpu_model (inM, instruction: [16]bool, res: bool)
returns (outM: [16]bool, writeM: bool, addressM: [15]bool, pc: [15]bool)
local a, d, a_m,
    load_A, sel_input_A,
    load_D,
    load_PC, inc_PC,
    out_PC,
    zr, ng,
    sel_A_M, c1, c2, c3, c4, c5, c6, d1, d2, d3, j1, j2, j3
do
  [|sel_A_M; c1; c2; c3; c4; c5; c6; d1; d2; d3; j1; j2; j3 |] =
    instruction.(3 .. 15)
and
  a = register16(mux16(outM, instruction, sel_input_A), load_A)
and
  d = register16(outM, load_D)
and
  a_m = mux16(a, inM, sel_A_M)
and
  outM, zr, ng = alu (d, a_m, c1, c2, c3, c4, c5, c6)
and
  writeM = d3 && instruction.(0)
and
  addressM = a.(1 .. 15)
and
  out_PC = pc_model(a, inc_PC, load_PC, res)
and
  pc = out_PC.(1 .. 15)
and
  sel_input_A = not(instruction.(0))
and
  load_A = not(instruction.(0)) or d1
and
  load_D = d2 && instruction.(0)
and
  inc_PC = true
and
  load_PC =
    (not j1 && not j2 &&     j3 && (not zr && not ng)) or
    (not j1 &&     j2 && not j3 && zr) or
    (not j1 &&     j2 &&     j3 && (zr or not ng)) or
    (    j1 && not j2 && not j3 && (not zr && ng)) or
    (    j1 && not j2 &&     j3 && not zr) or
    (    j1 &&     j2 && not j3 && (zr or ng)) or
    (    j1 &&     j2 &&     j3)
done

(* Incr Machine :  machine which increment a counter *)
let node rom32K_incr (address: [15]bool) returns (out_: [16]bool)
  out_ = if not(or_n_way<<15>>(address)) then
          (* D = 0 *)
          make<<3>>(true) ++ [|false|]
          ++ [|true; false; true; false; true; false|]
          ++ [| false; true; false |] ++ make<<3>>(false)
         else
          (* D = D + 1 *)
          make<<3>>(true) ++ [|false|]
          ++ [|false; true; true; true; true; true|]
          ++ [| false; true; false |] ++ make<<3>>(false)

let node incr_machine (res: bool) returns (out_: [16]bool)
 local instruction: [16]bool,
    pc: [15]bool,
    writeM: bool,
    addressM: [15]bool
 do
  instruction = rom32K_incr(pc)
 and
   out_, writeM, addressM, pc = cpu_model(make<<16>>(false), instruction, res)
 done

