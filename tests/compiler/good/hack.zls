(* exemples du processeur Hack - livre Nand2Tetris *)
(* et quelques autres *)

(* recherche par dichotomie dans un tableau *)
let rec dicho<<n>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2>>(v, x.(0 .. n/2 - 1))
           | _ -> dicho<<n-n/2-1>>(v, x.(n/2 + 1 .. n-1))

let main___1(x: [5]int) = dicho<<5>>(0, x)

let dicho_without_slices<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i>>(v, x:[m]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i>>(v, x)
           | _ -> dicho<<n - n/2,i+n/2>>(v, x) in
  dicho<<m,0>>(v, x)

let main___2(x) = dicho_without_slices<<42>>(0, x)

let rec dicho_without_slices_two<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i,l>>(v, x:[l]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i,l>>(v, x)
           | _ -> dicho<<n/2,i+n/2,l>>(v, x) in
   dicho<<m, 0, m>>(v, x)

let main___3(x) = dicho_without_slices<<42>>(0, x)

(* or n-way (linear) *)
let rec or_n<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(0) or or_n<<n-1>>(x.(1 .. n-1))

let or_n_linear_42(x) = or_n<<42>>(x)

(* or n-way (log) *)
let rec or_log<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | 1 -> y = x.(0)
    | _ -> y = or_log<<n/2>>(x.(0 .. n/2 - 1)) or
               or_log<<n-n/2>>(x.(n/2 .. n-1))

let or_n_log_42(x) = or_log<<42>>(x)

(* adders *)
let half_adder(a, b) returns (s, carry)
  do s = if a then not b else b
  and carry = a && b
  done
  
let xor(a, b) = if a then not b else b

let adder(a, b, c) returns (s, carry)
  local s1, c1, c2
  do s1, c1 = half_adder(a, b)
  and s, c2 = half_adder(c1, c)
  and carry = c1 or c2
  done
  
let full_adder(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = (a && b) or (b && c) or (a && c)
  done

(* adder *)
let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  match size n with
  | 0 -> o = [||]
  | _ -> let s, carry = full_adder(x.(0), y.(0), c) in
         o  = [|s|] ++
	      (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

(* decoding/multi-plexing *)
let decodeur_simple(sel, adr) returns (s0, s1)
  do
     s0 = sel && not adr
  and
     s1 = sel && adr
  done
  
let rec decodeur<<n,k>>(sel: bool, adr: [n]bool)
returns (s: [k]bool)
  local s0, s1 
  do
    (s0, s1) = decodeur_simple(sel, adr.(n-1))
  and
    match size n with
    | 1 -> do s = [|s0; s1|] done
    | _ -> do s = decodeur<<n-1, k/2>>(s0, adr.(0 .. n-2)) ++
                  decodeur<<n-1, k/2>>(s1, adr.(0 .. n-2)) done
  done

let decodeur_2(adr: [2]bool) returns (s: [4]bool)
  s = decodeur<<2,4>>(true, adr)

(*
-- multiplexeur
-- inverse d'un decodeur.
-- entree: une sur 2^n bits et une entree sur n bits.
-- sortie: choisie la n-ieme entree.
*)
let multiplexeur_simple(a0, b0, b1) returns (s)
  s = if a0 then b1 else b0

let multiplexeur_double(a0, a1, b0, b1, b2, b3) returns (s)
  local s0, s1, s2, s3 in
  do
   s = s0 or s1 or s2 or s3
  and
   s0 = b3 && a0 && a1
  and
   s1 = b2 && a1 && not a0
  and
   s2 = b1 && not a1 && a0
  and
   s3 = b0 && not a1 && not a0
  done

let rec multiplexeur_n<<n,k>>(a: [n]bool, b: [k]bool)
returns (s:bool)
  local s0, s1 in
  do
   match size n with
   | 1 -> do s0, s1 = b.(0), b.(1) done
   | _ -> do s0, s1 =
            multiplexeur_n<<n-1,k/2>>
	      (a.(0 .. n-2), b.(0 .. k/2 - 1)),
            multiplexeur_n<<n-1, k/2>>
	      (a.(0 .. n-2), b.(k/2 .. k - 1)) done
  and
   s = multiplexeur_simple(a.(n-1), s0, s1)
  done

let multiplexeur_2(a: [4]bool, b: [16]bool) returns (s: bool)
  s = multiplexeur_n<<4,16>>(a, b)

