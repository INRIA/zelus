(*
let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  o = match size n with
  | 0 -> [||]
  | _ -> let s, carry = true, true in
         [|s|] ++ (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

let add_42(x:[42]bool, y:[42]bool) returns (o:[42]bool)
  o = add_n<<42>>(x, y, false)
*)



let rec g___<<n>>() returns (o)
  o = match size n with
  | 0 -> true | 1 -> let k = true in k | _ -> g___<<n-n/2>>()

let main_1() = g___<<42>>()

let h_<<l>> =
 let rec f_<<n,m>> =
   match size n with
   | 0 -> true | 1 -> false | _ -> g_<<n-n/2,1>>
 and g_<<k,m>> = f_<<k,0>> in
 f_<<l,0>>

let rec f__<<n>> =
  match size n with
  | 0 -> true | _ -> false

let f___ = h_<<45>>


let rec f1<<n>>(x:[n]int) = f2<<n>>(x)
and f2<<n>>(x) = f1<<n>>(x)

let ff<<n>>(x) =
  match size n with
  | 0 -> 1
  | _ -> 2

let map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let g(x:[4]int) = my_concat<<4>>(x,x)

let rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

let rec fff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | _ -> y = [|1|] ++ fff<<n-1>>(x.(0 .. n-2))

let rec ffff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | 1 -> y = x
    | _ -> y = ffff<<n/2>>(x.(0 .. n/2 - 1)) ++
               ffff<<n - n/2>>(x.(n/2 .. n - 1))

let f42(x:[10]int) returns (o:[10]int) o = ffff<<10>>(x)

let f43(x:[1]int) returns (o:[1]int) o = fff<<1>>(x)

let rec dicho1<<n,i,l>>(v, x:[l]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho1<<n/2,i,l>>(v, x)
           | _ -> dicho1<<n/2,i+n/2,l>>(v, x)

let main___(x: [42]int) = dicho1<<42,0,42>>(0, x)

let rec dicho2<<n>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(n/2) with
           | 0 -> true
           | 1 -> dicho2<<n/2>>(v, x.(0 .. n/2 - 1))
           | _ -> dicho2<<n-n/2-1>>(v, x.(n/2 + 1 .. n-1))

let main____(x: [5]int) = dicho2<<5>>(0, x)


let dicho<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i>>(v, x)
           | _ -> dicho<<n/2,i+n/2>>(v, x) in
  dicho<<m,0>>(v, x)

let rec or_n<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(0) or or_n<<n-1>>(x.(1 .. n-1))

let rec or_n2<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(n-1) or or_n2<<n-1>>(x.(0 .. n-2))

let rec or_log<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    (* | 1 -> y = x.(0) *)
    | _ -> y = or_log<<n/2>>(x.(0 .. n/2 - 1)) or
               or_log<<n-n/2>>(x.(n/2 .. n-1))

let or_n_42(x) = or_n<<42>>(x)

let half_adder(a, b) returns (s, carry)
  s = if a then not b else b
  and
  carry = a && b

let xor(a, b) = if a then not b else b

let adder(a, b, c) returns (s, carry)
  local s1, c1, c2
  do s1, c1 = half_adder(a, b)
  and s, c2 = half_adder(c1, c)
  and carry = c1 or c2
  done
  
let full_adder(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = (a && b) or (b && c) or (a && c)
  done

let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  match size n with
  | 0 -> o = [||]
  | _ -> let s, carry = full_adder(x.(0), y.(0), c) in
         o  = [|s|] ++
	      (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

let decodeur_simple(sel, adr) returns (s0, s1)
  do
     s0 = sel && not adr
  and
     s1 = sel && adr
  done
  
let rec decodeur<<n,k>>(sel: bool, adr: [n]bool)
returns (s: [k]bool)
  local s0, s1 
  do
    (s0, s1) = decodeur_simple(sel, adr.(n-1))
  and
    match size n with
    | 1 -> do s = [|s0; s1|] done
    | _ -> do s = decodeur<<n-1, k/2>>(s0, adr.(0 .. n-2)) ++
                  decodeur<<n-1, k/2>>(s1, adr.(0 .. n-2)) done
  done

let decodeur_2(adr: [2]bool) returns (s: [4]bool)
  s = decodeur<<2,4>>(true, adr)

(*
-- multiplexeur
-- inverse d'un decodeur.
-- entree: une sur 2^n bits et une entree sur n bits.
-- sortie: choisie la n-ieme entree.
*)
let multiplexeur_simple(a0, b0, b1) returns (s)
  s = if a0 then b1 else b0

let multiplexeur_double(a0, a1, b0, b1, b2, b3) returns (s)
  local s0, s1, s2, s3 in
  do
   s = s0 or s1 or s2 or s3
  and
   s0 = b3 && a0 && a1
  and
   s1 = b2 && a1 && not a0
  and
   s2 = b1 && not a1 && a0
  and
   s3 = b0 && not a1 && not a0
  done

let rec multiplexeur_n<<n,k>>(a: [n]bool, b: [k]bool)
returns (s:bool)
  local s0, s1 in
  do
   match size n with
   | 1 -> do s0, s1 = b.(0), b.(1) done
   | _ -> do s0, s1 =
            multiplexeur_n<<n-1,k/2>>
	      (a.(0 .. n-2), b.(0 .. k/2 - 1)),
            multiplexeur_n<<n-1, k/2>>
	      (a.(0 .. n-2), b.(k/2 .. k - 1)) done
  and
   s = multiplexeur_simple(a.(n-1), s0, s1)
  done

let multiplexeur_2(a: [4]bool, b: [16]bool) returns (s: bool)
  s = multiplexeur_n<<4,16>>(a, b)

(* val or_1 : <<n>>.([n]bool -> bool) with { n/2 <= n; 0 < n/2 } *)

(* let rec decoder<<n>>(adr:[n]bool) returns (i:[2^n]bool)
  sizeof n with
  | 0 ->
  | n+1 ->  decoder<<n>>(adr.(1..n-1)) ++ decoder<<n>>(adr.(1..n-1)) *)

(*
let const f<<n>>(f)(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = f xi done
*)



(* let node f0 g x = run g x

let const fix (const f) x = let rec y = f x y in y
*)

(*
let fix f x = let rec y = f x y in y

let g x = fix (fun x y -> x) x

let pid (integr)(deriv) =
  node (h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node pid2 (integr)(deriv)(h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node mon_pid (e)=
 pid
    (node (h, x0, x') returns (x) do x = 0.0 fby (x *. h *. x') done)
    (node (h, x) -> (x -. pre(x)) /. h) e

let node pid_ e = mon_pid(0.1, 0.1, 0.1, 0.1, e)
*)
 

