let const map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let const my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let const my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let const rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

let const rec or_<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else y = x.(0) default false || (or_<<n-1>>(x.(0 .. n-2)))

let const rec or__1<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else if n = 1 then y = x.(n-1)
    else
      y = (or__1<<n/2>>(x.(0 .. (n/2 - 1)))) or
          (or__1<<n/2>>(x.((n/2) .. (n - 1))))

val or_1 : <<n>>.([n]bool -> bool) with { n/2 <= n; 0 < n/2 }

let rec or__1<<n>>(x:[n]bool) returns (y])
  sizeof n with
  | 0 -> y = false
  | 1 -> y = x.(0)
  | k by 2 rem r -> 
      y = (or__1<<k>>(x.(0 .. k - 1))) 
                      or (or__1<<n-k>>(x.(k .. n-1)))

let rec or__3<<n>>(x:[n]bool) returns (y)
  match x with
  | [||] -> y = false
  | x0 . x -> y = x0 or or__3<<n-1>>(x)

let rec or__2<<n>>(x:[n]bool) returns (y)
  sizeof n with
  | 0 -> y = false
  | n + 1 -> y = x.(0) or or__2<<n>>(x.(0..n-2))

let rec decoder<<n>>(adr:[n]bool) returns (i:[2^n]bool)
  sizeof n with
  | 0 ->
  | n+1 ->  decoder<<n>>(adr.(1..n-1)) ++ decoder<<n>>(adr.(1..n-1))

(*
let const f<<n>>(f)(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = f xi done
*)



(* let node f0 g x = run g x

let const fix (const f) x = let rec y = f x y in y
*)

(*
let fix f x = let rec y = f x y in y

let g x = fix (fun x y -> x) x

let pid (integr)(deriv) =
  node (h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node pid2 (integr)(deriv)(h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node mon_pid (e)=
 pid
    (node (h, x0, x') returns (x) do x = 0.0 fby (x *. h *. x') done)
    (node (h, x) -> (x -. pre(x)) /. h) e

let node pid_ e = mon_pid(0.1, 0.1, 0.1, 0.1, e)
*)
    

