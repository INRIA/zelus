let const ff<<n>>(x) =
  match size n with
  | 0 -> 1
  | _ -> 2

let const map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let const my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let const my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let const g(x:[4]int) = my_concat<<4>>(x,x)

let const rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

(* 
let map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let g(x:[4]int) = my_concat<<4>>(x,x)

let rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

let rec or_n<<n>> =
  fun (x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = [||]
    | 1 -> y = x.(0)
    | _ -> or_n<<n/2>>(x.(0 .. n/2 - 1)) || or_n<<n-n/2>>(x.(n/2 .. n - 1)
*)

(* let dicho<<n>>(v, x) =
     let rec dicho<<n,i>>(v, x) =
       match size n with
       | 0 -> false
       | _ -> match compare v x.(i+n/2) with
              | 0 -> true
              | 1 -> dicho<<n/2,i>>(v, x)
              | _ -> dicho<<n/2,i+n/2>>(v, x) in
     dicho<<n,0>>(v, x)

val f : <<n>>. [n]int -> [n]int with 
  let rec dicho(n,i) = if n < 0 then false
                       else if n = 0 then true
                       else i+n/2 < n) & (dicho(n/2, i) && dicho(n/2, i+n/2) in
  dicho(n,0)

let rec nat n = match n with | 0 -> true | _ -> (n-2) <= n & sat(n-1)

f<<n1,....,nk>> = ... f<<s1,...,sk>>

if (s1 = n1) then (...) else s1 < n1
*)

(*
let const rec or_<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else y = x.(0) default false || (or_<<n-1>>(x.(0 .. n-2)))

let const rec or__1<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else if n = 1 then y = x.(n-1)
    else
      y = (or__1<<n/2>>(x.(0 .. (n/2 - 1)))) or
          (or__1<<n/2>>(x.((n/2) .. (n - 1))))
*)

(* val or_1 : <<n>>.([n]bool -> bool) with { n/2 <= n; 0 < n/2 } *)

(* let rec decoder<<n>>(adr:[n]bool) returns (i:[2^n]bool)
  sizeof n with
  | 0 ->
  | n+1 ->  decoder<<n>>(adr.(1..n-1)) ++ decoder<<n>>(adr.(1..n-1)) *)

(*
let const f<<n>>(f)(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = f xi done
*)



(* let node f0 g x = run g x

let const fix (const f) x = let rec y = f x y in y
*)

(*
let fix f x = let rec y = f x y in y

let g x = fix (fun x y -> x) x

let pid (integr)(deriv) =
  node (h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node pid2 (integr)(deriv)(h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node mon_pid (e)=
 pid
    (node (h, x0, x') returns (x) do x = 0.0 fby (x *. h *. x') done)
    (node (h, x) -> (x -. pre(x)) /. h) e

let node pid_ e = mon_pid(0.1, 0.1, 0.1, 0.1, e)
*)
    

