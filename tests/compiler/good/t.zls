let rec f_<<n>> =
  match size n with
  | 0 -> true | _ -> g_<<n-1>>
and g_<<k>> = f_<<k>>

let rec f__<<n>> =
  match size n with
  | 0 -> true | _ -> false

let f___ = f_<<1>>


let rec f1<<n>>(x:[n]int) = f2<<n>>(x)
and f2<<n>>(x) = f1<<n>>(x)

let ff<<n>>(x) =
  match size n with
  | 0 -> 1
  | _ -> 2

let map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let g(x:[4]int) = my_concat<<4>>(x,x)

let rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

let rec fff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | _ -> y = [|1|] ++ fff<<n-1>>(x.(0 .. n-2))

let rec ffff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | 1 -> y = x
    | _ -> y = ffff<<n/2>>(x.(0 .. n/2 - 1)) ++ ffff<<n - n/2>>(x.(n/2 .. n - 1))

let f42(x:[10]int) returns (o:[10]int) o = ffff<<10>>(x)

let f43(x:[1]int) returns (o:[1]int) o = fff<<1>>(x)

let rec dicho1<<n,i,l>>(v, x:[l]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho1<<n/2,i,l>>(v, x)
           | _ -> dicho1<<n/2,i+n/2,l>>(v, x)

let main___(x: [42]int) = dicho1<<42,0,42>>(0, x)

let rec dicho2<<n>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(n/2) with
           | 0 -> true
           | 1 -> dicho2<<n/2>>(v, x.(0 .. n/2 - 1))
           | _ -> dicho2<<n-n/2-1>>(v, x.(n/2 + 1 .. n-1))

let main____(x: [5]int) = dicho2<<5>>(0, x)


let dicho<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i>>(v, x)
           | _ -> dicho<<n/2,i+n/2>>(v, x) in
  dicho<<m,0>>(v, x)

(*
let const rec or_<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else y = x.(0) default false || (or_<<n-1>>(x.(0 .. n-2)))

let const rec or__1<<n>>(x:[n]bool) returns (y)
    if n = 0 then y = false
    else if n = 1 then y = x.(n-1)
    else
      y = (or__1<<n/2>>(x.(0 .. (n/2 - 1)))) or
          (or__1<<n/2>>(x.((n/2) .. (n - 1))))
*)

(* val or_1 : <<n>>.([n]bool -> bool) with { n/2 <= n; 0 < n/2 } *)

(* let rec decoder<<n>>(adr:[n]bool) returns (i:[2^n]bool)
  sizeof n with
  | 0 ->
  | n+1 ->  decoder<<n>>(adr.(1..n-1)) ++ decoder<<n>>(adr.(1..n-1)) *)

(*
let const f<<n>>(f)(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = f xi done
*)



(* let node f0 g x = run g x

let const fix (const f) x = let rec y = f x y in y
*)

(*
let fix f x = let rec y = f x y in y

let g x = fix (fun x y -> x) x

let pid (integr)(deriv) =
  node (h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node pid2 (integr)(deriv)(h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node mon_pid (e)=
 pid
    (node (h, x0, x') returns (x) do x = 0.0 fby (x *. h *. x') done)
    (node (h, x) -> (x -. pre(x)) /. h) e

let node pid_ e = mon_pid(0.1, 0.1, 0.1, 0.1, e)
*)
    

