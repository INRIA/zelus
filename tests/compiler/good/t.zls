let rec add_n<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  o = match size n with
  | 0 -> [||]
  | _ -> let s, carry = true, true in
         [|s|] ++ (add_n<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))

let add_42(x:[42]bool, y:[42]bool) returns (o:[42]bool)
  o = add_n<<42>>(x, y, false)

(*


let rec g___<<n>>() returns (o)
  o = match size n with
  | 0 -> true | 1 -> let k = true in k | _ -> g___<<n-n/2>>()

let main_1() = g___<<42>>()

let rec f_<<n>> =
  match size n with
  | 0 -> true | 1 -> false | _ -> g_<<n-n/2>>
and g_<<k>> = f_<<k-1>>

let rec f__<<n>> =
  match size n with
  | 0 -> true | _ -> false

let f___ = f_<<42>>


let rec f1<<n>>(x:[n]int) = f2<<n>>(x)
and f2<<n>>(x) = f1<<n>>(x)

let ff<<n>>(x) =
  match size n with
  | 0 -> 1
  | _ -> 2

let map<<n>>(f)(x:[n]'a) returns (y:[n]'b)
 forward(n)[i] (xi in x) returns (yi out y)
    do yi = f(xi) + i done
    
let my_concat<<n>>(x:[n]'a, y:[n]'a) =
  x ++ y ++ [|1|] ++ [|2;3;4|]

let my_concat2<<n>>(x:[n]'a, y:[n]'a)
returns (z:[2 * n + 4]'a)
  z = x ++ y ++ [|1|] ++ [|2;3;4|]

let g(x:[4]int) = my_concat<<4>>(x,x)

let rec f<<n>>(x:[n]int) returns (y:[n]int)
    if n = 0 then y = x else
    y = [|1|] ++ f<<n-1>>(x.(0 .. n-2))

let rec fff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | _ -> y = [|1|] ++ fff<<n-1>>(x.(0 .. n-2))

let rec ffff<<n>>(x:[n]int) returns (y:[n]int)
    match size n with
    | 0 -> y = x
    | 1 -> y = x
    | _ -> y = ffff<<n/2>>(x.(0 .. n/2 - 1)) ++ ffff<<n - n/2>>(x.(n/2 .. n - 1))

let f42(x:[10]int) returns (o:[10]int) o = ffff<<10>>(x)

let f43(x:[1]int) returns (o:[1]int) o = fff<<1>>(x)

let rec dicho1<<n,i,l>>(v, x:[l]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho1<<n/2,i,l>>(v, x)
           | _ -> dicho1<<n/2,i+n/2,l>>(v, x)

let main___(x: [42]int) = dicho1<<42,0,42>>(0, x)

let rec dicho2<<n>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(n/2) with
           | 0 -> true
           | 1 -> dicho2<<n/2>>(v, x.(0 .. n/2 - 1))
           | _ -> dicho2<<n-n/2-1>>(v, x.(n/2 + 1 .. n-1))

let main____(x: [5]int) = dicho2<<5>>(0, x)


let dicho<<m>>(v, x:[m]'a) =
  let rec dicho<<n,i>>(v, x:[n]'a) =
    match size n with
    | 0 -> false
    | _ -> match compare v x.(i+n/2) with
           | 0 -> true
           | 1 -> dicho<<n/2,i>>(v, x)
           | _ -> dicho<<n/2,i+n/2>>(v, x) in
  dicho<<m,0>>(v, x)

let rec or_n<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(0) or or_n<<n-1>>(x.(1 .. n-1))

let rec or_n2<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | _ -> y = x.(n-1) or or_n2<<n-1>>(x.(0 .. n-2))

let rec or_log<<n>>(x:[n]bool) returns (y)
    match size n with
    | 0 -> y = false
    | 1 -> y = x.(0)
    | _ -> y = or_log<<n/2>>(x.(0 .. n/2 - 1)) or or_log<<n-n/2>>(x.(n/2 .. n-1))

let or_n_42(x) = or_n<<42>>(x)
let or_log_43(x) = or_log<<43>>(x)

let half_adder(a, b) returns (s, carry)
  s = if a then not b else b
  and
  carry = a && b

let xor(a, b) = if a then not b else b

let adder(a, b, c) returns (s, carry)
  local s1, c1, c2
  do s1, c1 = half_adder(a, b)
  and s, c2 = half_adder(c1, c)
  and carry = c1 or c2
  done
  
let full_adder(a, b, c) returns (s, carry)
  do  s = xor(a, xor(b, c))
  and carry = (a && b) or (b && c) or (a && c)
  done

let rec add_n2<<n>>(x:[n]bool, y:[n]bool, c) returns (o:[n]bool)
  match size n with
  | 0 -> o = [||]
  | _ -> let s, carry = full_adder(x.(0), y.(0), c) in
         o  = [|s|] ++ (add_n2<<n-1>>(x.(1 .. n-1), y.(1 .. n-1), carry))
	 
(* val or_1 : <<n>>.([n]bool -> bool) with { n/2 <= n; 0 < n/2 } *)

(* let rec decoder<<n>>(adr:[n]bool) returns (i:[2^n]bool)
  sizeof n with
  | 0 ->
  | n+1 ->  decoder<<n>>(adr.(1..n-1)) ++ decoder<<n>>(adr.(1..n-1)) *)

(*
let const f<<n>>(f)(x) returns (y)
  forward(n) (xi in x) returns (yi out y)
    do yi = f xi done
*)



(* let node f0 g x = run g x

let const fix (const f) x = let rec y = f x y in y
*)

(*
let fix f x = let rec y = f x y in y

let g x = fix (fun x y -> x) x

let pid (integr)(deriv) =
  node (h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node pid2 (integr)(deriv)(h, p, i, d, e) returns (u)
    u = run integr (h, 0.0, i *. e) +. run deriv (h, d *. e) +. p *. e

let node mon_pid (e)=
 pid
    (node (h, x0, x') returns (x) do x = 0.0 fby (x *. h *. x') done)
    (node (h, x) -> (x -. pre(x)) /. h) e

let node pid_ e = mon_pid(0.1, 0.1, 0.1, 0.1, e)
*)
    
*)

