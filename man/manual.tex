% vim:nojs:spelllang=en_us tw=76 sw=4 sts=4 fo+=awn fmr={-{,}-} et ts=8
\documentclass[11pt,titlepage,twoside]{report}
%{-{1 Packages
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}

\usepackage{hevea}
\usepackage[subdir=samples,
            prefix=tutorial,
            ext=.zls,
            prompt={aneto.local:\ },
            compiler={../compiler/zeluc.byte},
            compilerflags={-I ../lib -I ./samples},
            lastflags={-i},
            includecmd={},
            html={../tools/zltohtml},
           ]{checklistings}
\ifhevea
\newcommand{\zls}[1]{{\@span{class="zelusinline"}#1}}
\else
\fvset{xleftmargin=3mm}
\checklistings{errstyle={formatcom=\small}}
\newcommand{\zls}[1]{\texttt{#1}}
\fi
%BEGIN IMAGE
\renewcommand{\zls}[1]{\texttt{#1}}
%END IMAGE

\newcommand{\zlsmsg}[1]{\texttt{#1}}

\usepackage{a4wide}
\usepackage{alltt}
\usepackage{color}
\usepackage{graphicx}
\usepackage{epsf}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage[nameinlink]{cleveref}

\crefname{figure}{figure}{figures}

\ifhevea
\newenvironment{flatitemize}
  {\setenvclass{itemize}{flatitemize}%
   \begin{itemize}}
  {\end{itemize}}
\newenvironment{anumerate}
  {\begin{divstyle}{anumerate}\begin{enumerate}}
  {\end{enumerate}\end{divstyle}}
\newenvironment{cdescription}
  {\begin{divstyle}{cdescription}\begin{description}}
  {\end{description}\end{divstyle}}
\newenvironment{ddescription}
  {\begin{divstyle}{ddescription}\begin{description}}
  {\end{description}\end{divstyle}}
\else
\usepackage[inline]{enumitem}
\newenvironment{flatitemize}
  {\begin{itemize}[leftmargin=*]}
  {\end{itemize}}
\newenvironment{anumerate}
  {\begin{enumerate}[label=(\emph{\alph*})]}
  {\end{enumerate}}
\newenvironment{cdescription}
  {\begin{description}[leftmargin=3.5em,style=multiline]}
  {\end{description}}
\newenvironment{ddescription}
  {\begin{description}[leftmargin=6.0em,style=multiline]}
  {\end{description}}
\fi

\usepackage{tikz}
\usetikzlibrary{positioning,chains,matrix,shapes.arrows,scopes,
                shapes.misc,arrows,automata,calc,decorations.markings,
                decorations.text,circuits.logic.US}

%}-}1
%{-{1 Macros

\ifhevea
\newcommand{\footnoteurl}[2]{\ahref{#2}{#1}}
\else
\newcommand{\footnoteurl}[2]{{#1}\footnote{\url{#2}}}
\fi


\newcommand{\f}{$F$}
\renewcommand{\t}{$T$}

\newcommand{\F}{\texttt{false}}
\newcommand{\T}{\texttt{true}}

\newcommand{\nil}{$\mathit{nil}$}

\newcommand{\cvode}{{\sc CVODE}}
\newcommand{\ly}{\ensuremath{\mathit{ly}}}
\newcommand{\lx}{\ensuremath{\mathit{lx}}}
\newcommand{\step}{\ensuremath{\mathit{step}}}
\newcommand{\init}{\ensuremath{\mathit{init}}}
\newcommand{\encore}{\ensuremath{\mathit{encore}}}
\newcommand{\field}{\ensuremath{\mathit{field}}}
\newcommand{\method}{\ensuremath{\mathit{method}}}

\newcommand{\rulename}[1]{{\small\sc ({#1})}}

\newcommand{\Solve}[2]{\mathit{solve}({#1})({#2})}

\newcommand{\Ifthenelse}[3]
   {\mathit{if}\,{#1}\,\mathit{then}\,{#2}\,\mathit{else}\,{#3}}

\tikzset{weak/.style={
    decoration={markings,
                mark=at position -.6mm with {\draw[fill=white] circle (.9mm);},
                mark=at position -1.1mm with {\arrow{latex}}},
    postaction={decorate},
    thick}}

\tikzset{strong/.style={
    decoration={markings,
                mark=at position .6mm with {\draw[fill=white] circle (.9mm);}},
    postaction={decorate},
    thick,
    -latex}}

\tikzset{zelus automata/.style={
    semithick,
    auto,
    node distance=4.5cm,
    initial text=,
    initial where=above,
    every initial by arrow/.style={-latex},
    every state/.style={rounded rectangle,thick},
}}

\long\def\framed#1{\framebox[\textwidth]{\vbox{\begin{center}#1\end{center}}}}
%utiliser \framed{...}

\newcommand{\zelus}{{\sf Z\'elus}}
\newcommand{\lucid}{{\sf Lucid}}
\newcommand{\lustre}{{\sf Lustre}}
\newcommand{\lucy}{{\sf Lucid Synchrone}}
\newcommand{\simulink}{{\sf Simulink}}
\newcommand{\stateflow}{{\sf Stateflow}}
\newcommand{\modelica}{{\sf Modelica}}
\newcommand{\scade}{{\sf SCADE}}
\newcommand{\scadesix}{{\sf SCADE~6}}
\newcommand{\esterel}{{\sf Esterel}}
\newcommand{\signal}{{\sf Signal}}
\newcommand{\statecharts}{{\sf StateCharts}}
\newcommand{\camllight}{{\sf Caml Light}}
\newcommand{\ocaml}{{\sf OCaml}}
\newcommand{\standardml}{{\sf Standard-ML}}
\newcommand{\lazyml}{{\sf Lazy-ML}}
\newcommand{\haskell}{{\sf Haskell}}
\newcommand{\ml}{{\sf ML}}
\newcommand{\inria}{{\sf INRIA}}
\newcommand{\alt}{\;|\;}

\newcommand{\zelusc}{\mbox{{\tt lucyc}}}

\newcommand{\AndEq}[2]{{#1}\,\mbox{{\tt and}}\,{#2}}

\newcommand{\Let}{\mbox{{\tt let}}}
\newcommand{\Rec}{\mbox{{\tt rec}}}
\newcommand{\In}{\mbox{{\tt in}}}
\newcommand{\AND}{\mbox{{\tt and}}}
\newcommand{\Const}{\mbox{{\tt const}}}
\newcommand{\Fun}{\mbox{{\tt fun}}}
\newcommand{\Node}{\mbox{{\tt node}}}
\newcommand{\Emit}{\mbox{{\tt emit}}}
\newcommand{\Function}{\mbox{{\tt function}}}
\newcommand{\Arrow}{\mbox{{\tt ->}}}
\newcommand{\If}{\mbox{{\tt if}}}
\newcommand{\Then}{\mbox{{\tt then}}}
\newcommand{\Else}{\mbox{{\tt else}}}
\newcommand{\Merge}{\mbox{{\tt merge}}}
\newcommand{\Not}{\mbox{{\tt not}}}
\newcommand{\Up}{\mbox{{\tt up}}}
\newcommand{\Pre}{\mbox{{\tt pre}}}
\newcommand{\Last}{\mbox{{\tt last}}}
\newcommand{\Run}{\mbox{{\tt run}}}
\newcommand{\Await}{\mbox{{\tt await}}}
\newcommand{\Fby}{\mbox{{\tt fby}}}
\newcommand{\When}{\mbox{{\tt when}}}
\newcommand{\Whenot}{\mbox{{\tt whenot}}}
\newcommand{\Extend}{\mbox{{\tt extend}}}
\newcommand{\Minusgreater}{\mbox{{\tt ->}}}
\newcommand{\Equalgreater}{\mbox{{\tt =>}}}
\renewcommand{\Reset}{\mbox{{\tt reset}}}
\newcommand{\Every}{\mbox{{\tt every}}}
\newcommand{\Nil}{\mbox{{\tt Nil}}}
\newcommand{\Semisemi}{\mbox{{\tt ;;}}}
\newcommand{\On}{\mbox{{\tt on}}}
\newcommand{\Clock}{\mbox{{\tt clock}}}

\newcommand{\Where}{\mbox{{\tt where}}}
\newcommand{\Leq}{\mbox{{\tt <=}}}
\newcommand{\Le}{\mbox{{\tt <}}}
\newcommand{\Geq}{\mbox{{\tt >=}}}
\newcommand{\Ge}{\mbox{{\tt >}}}
\newcommand{\Neq}{\mbox{{\tt <>}}}
\newcommand{\Add}{\mbox{{\tt +}}}
\newcommand{\Mult}{\mbox{{\tt *}}}
\newcommand{\Or}{\mbox{{\tt or}}}
\newcommand{\Minus}{\mbox{{\tt -}}}
\newcommand{\Div}{\mbox{{\tt /}}}
\newcommand{\Mod}{\mbox{{\tt mod}}}
\newcommand{\false}{\mbox{{\em false}}}
\newcommand{\true}{\mbox{{\em true}}}
\newcommand{\End}{\mbox{{\tt end}}}

\newcommand{\DotNotation}[1]{\frac{\mathit{d}{#1}}{\mathit{dt}}}

\newcommand{\Nat}{I\!\!N}
\newcommand{\bR}{\mathbb{R}}
\newcommand{\bB}{\mathbb{B}}
\newcommand{\bN}{\mathbb{N}}

\newcommand{\Match}[2]{\mbox{\tt match}\ #1\ \mbox{\tt with}\ #2 \End}
\newcommand{\Automaton}[1]{\mbox{\tt automaton}\ {#1} \End}
\newcommand{\Present}[1]{\mbox{\tt present}\ {#1} \End}
\newcommand{\Until}{\mbox{\tt until}}
\newcommand{\Unless}{\mbox{\tt unless}}
%\newcommand{\Then}{\mbox{\tt then}}
\newcommand{\Continue}{\mbox{\tt continue}}
\newcommand{\Do}{\mbox{\tt do}}
\newcommand{\Done}{\mbox{\tt done}}

\newenvironment{paulo}{{\bf Paulo}}{{\bf fin Paulo}}
\newenvironment{marc}{{\bf Marc}}{{\bf fin Marc}}
\newenvironment{tim}{{\bf Tim}}{{\bf fin Tim}}

\newcommand{\Marc}[1]{{\bf Marc.} {#1} {\bf Fin}}
\newcommand{\Tim}[1]{{\bf Tim.} {#1} {\bf Fin}}

% Pour le manuel de ref
\ifhevea
\newcommand{\term}[1]{\textcolor{Blue}{\tt #1}}
\newcommand{\nterm}[1]{\textcolor{BrickRed}{\it #1}}
\else
\newcommand{\term}[1]{{\tt #1}}
\newcommand{\nterm}[1]{{\em #1}}
\fi

% Un environnement pour les chronogrammes
\newenvironment{chrono}[1]
  {\begin{divstyle}{chrono}\center\tabular{#1}}
  {\endtabular\endcenter\end{divstyle}}

%\newenvironment{sample}
%  {\begin{flushleft} \begin{tabular}{p{.0cm}l}
%   &\begin{minipage}[t]{10cm} \begin{alltt}} {\end{alltt}
%   \end{minipage} \end{tabular}\end{flushleft}}

\ifhevea
\setenvclass{zelusprompt}{zelusprompt}
\newenvironment{sample}
  {\@open{div}{\envclass@attr{zelusprompt}}
   \begin{alltt}}
  {\end{alltt}\@close{div}}
\else
\newenvironment{sample}
  {\begin{flushright}\begin{minipage}[t]{15.3cm}\begin{alltt}\small}
  {\end{alltt}\end{minipage}\end{flushright}}
\fi

\newcommand{\shell}[1]{{\em aneto.local: #1}}
\ifhevea
\newcommand{\sig}[1]{\textcolor{OliveGreen}#1}
\else
\newcommand{\sig}[1]{{\em #1}}
\fi

\newcommand{\AnyKind}{\ensuremath{\mathtt{A}}}
\newcommand{\NodeKind}{\ensuremath{\mathtt{D}}}
\newcommand{\HybridKind}{\ensuremath{\mathtt{C}}}

\newcommand{\Remark}{\medskip\noindent{\bf Remark: }}

% }-}1
\begin{document}
%{-{1
\pagestyle{empty}

% we make a special title page for HeVeA
%BEGIN LATEX
\vfill

\noindent {\huge \bf Z\'elus: a Synchronous Language with ODEs}
%Hybrid Synchronous Language}
\\[2ex]
{\Large Release, version 1.2}


\vspace{7cm}

\begin{center}
{\Huge \bf Tutorial and Reference Manual} \\

\vspace{1cm}
{\Large \url{http://zelus.di.ens.fr}}
\vspace{1.5cm}

{\Large Marc Pouzet} \\[2ex]
{\Large Albert Benveniste, Timothy Bourke and Benoit Caillaud} \\[4ex]
{\large Inria Project Team PARKAS, \\
\'Ecole normale sup\'erieure, \\ 45 rue d'Ulm,
75230 Paris, France} \\[2ex]
{\Large January 2015} \\

\end{center}
% \vfill
% {\small \begin{verbatim}
% $Id: manual.tex,v 1.12 2009-02-08 11:15:55 pouzet Exp $
% \end{verbatim}}
%END LATEX
\begin{rawhtml}
</p>
<div class="manualtitle">
  <h1>Zélus: A Synchronous Language with ODEs</h1>
  <h2>Tutorial and Reference Manual</h2>
  <h2>Release, version 1.2</h2>

  <ul class="authors">
    <li class="first"><a href="mailto:Marc.Pouzet@ens.fr">Marc Pouzet</a></li>
    <li><a href="mailto:Albert.Benveniste@inria.fr">Albert Benveniste</a></li>
    <li><a href="mailto:Timothy.Bourke@inria.fr">Timothy Bourke</a></li>
    <li><a href="mailto:Benoit.Caillaud@inria.fr">Benoit Caillaud</a></li>
  </ul>

  <div class="date">January 2015</div>
  <div class="address">
    Project Team PARKAS<br/>
    École normale supérieure<br/>
    45 rue d'Ulm<br/>
    75230 Paris, France
  </div>
</div>
<p>
\end{rawhtml}

\newpage
\cleardoublepage
\tableofcontents
\cleardoublepage

\newcommand{\Left}{\mathit{left}}
\newcommand{\Right}{\mathit{right}}

% }-}1
\chapter*{Foreword\label{foreword}} %{-{1

\zelus{} is a synchronous language extended with
Ordinary Differential Equations.
It is for programming systems that mix discrete-time and continuous-time
behaviors, like, for instance, real-time control software executing in 
closed loop with a model of its physical environment.
More intricate interactions between discrete- and continuous-time behaviors 
can be expressed, like, for instance, continuous-time PID controllers or 
hybrid automata with modes defined by ODEs.
%It is also possible to program more intricate interactions between discrete 
%and continuous-time, both for the controller or
%the physical plant: discrete or continuous-time PID controllers,
%hybrid automata with modes defined by ODEs, etc.
%With \zelus, the model of the software and the
%physical environment can be written in the very same source.
\zelus{} provides basic synchronous language constructs---difference and 
data-flow equations, hierarchical automata, and stream function 
definitions---in the style of \lustre~\cite{lustre:ieee91} and
\lucy~\cite{lucy:iste07}.
The extension with ODEs for modeling continuous-time behaviors is 
conservative.
The expressiveness of the language is deliberately constrained to statically 
ensure determinism and the generation of loop-free sequential code that runs 
in bounded time and space. Moreover, code is generated identically for both 
embedded targets and simulation. For source programs with ODEs, the 
generated sequential code is paired with a numerical solver to approximate 
the continuous-time dynamics.
%
%(type inference, causality and initialization analyses, support for freely 
%mixing data-flow equations and automata).
\zelus's main features are:
\begin{flatitemize}
\item
It is a data-flow language in Single Static Assignment form: every name has 
only a single definition in the source code at any instant. A program is a 
collection of functions from signals to signals. A \emph{signal} is a 
function from time
to values. A set of signals is defined uniquely as
the solution of a set of mutually recursive equations.
\item
The separation between discrete-time and continuous-time signals and
systems is imposed at the level of function definitions:
  \begin{enumerate}
  \item
    A \emph{node} is a function from discrete-time signals to
    discrete-time signals. A discrete-time signal is a sequence of values (a 
    \emph{stream}) as in other synchronous languages.
    A node is executed consecutively over the elements of a sequence of 
    inputs to give a sequence of outputs.
    Nodes have no other notion of time than this succession of instants.
    In particular, there is no a~priori `distance' (time elapsed) between 
    two instants.
    Outputs are produced atomically with triggering inputs, that is, 
    instantaneously in the same discrete instant.
    They may depend on previous inputs; such nodes are termed 
    \emph{stateful}.
    %A node is executed on a sequence of instants.
    %%, i.e., enumerated with
    %%an integer value.
    %Nodes may be stateful, that is, their outputs at an instant may depend 
    %on previous inputs.
    %It may be
    %stateful, that is, its current output may depend on previous
    %inputs, or not and is produced instantaneously with the read of inputs.
    %In a node, time is logical, that is, no hypothesis is made on the time that elapses
    %between two successive instants.
    % and treat signals as successions of values in a
    % sequence.% \zelus{} is a conservative extension of an existing
    % synchronous language.% Given the main function of the system, the
    % compiler
%     produces a \emph{step} function that computes a single reaction of
%     the system and which is guaranteed to run in bounded time and
%     memory provided functions imported from the host language also do
%     so.
  \item
    A \emph{hybrid node} is a function from continuous-time signals to
    continuous-time signals. A continuous-time signal is a signal
    defined on a sequence of time intervals on the real
    line.
    %~\footnote{$\forall n. t(i) = [\Left(i),\Right(i)]$ with
    %  $0 \leq \Left(0)$ and $\Right(i) \leq \Left(i+1)$}.
    A hybrid node is executed on this set of instants. Only hybrid nodes
    may contain ODEs and detect zero-crossing events.
  \end{enumerate}
\item
All
discrete-time computations must be executed on a \emph{discrete clock}.
This is statically enforced by the type system, following the convention:

\begin{quote}
A clock is termed \emph{discrete} if it has been so declared or if it 
results from the sub-sampling a discrete clock or a zero-crossing.
Otherwise, it is termed \emph{continuous}.
\end{quote}

It is possible to reset a continuous variable defined by an ODE
on a discrete clock.
A \emph{zero-crossing} occurs when a continuous-time signal crosses zero 
from a negative value to a positive one during integration.
Conceptually, a \emph{timer} is a particular case of a zero-crossing event, 
even if the actual implementation is more specific.

\item
  The basic types like integers, floating-point numbers, booleans, and
  characters are lifted from the host language \ocaml.  Abstract types,
  product types, record types, and enumerated types can either be
  defined directly or imported from the host language. Functions may have 
  polymorphic types as in \emph{ML}.
  Structured values are accessed via pattern matching.

\item
Data-flow equations may be composed arbitrarily with hierarchical automata 
as in
\ifhevea
\ahref{http://www.di.ens.fr/\textasciitilde{}pouzet/lucid-synchrone/}{\lucy}
\else
\lucy\footnote{\url{http://www.di.ens.fr/~pouzet/lucid-synchrone/}}
\fi
and
\footnoteurl{\scadesix.}{http://www.esterel-technologies.com/products/scade-suite/}
The compiler ensures determinacy and the absence of infinite loops.
Hierarchical automata are internally rewritten into data-flow equations.

\item
The compiler is written in \ocaml{} as a series of
source-to-source and traceable transformations that ultimately yield
statically scheduled sequential \ocaml code.
The results of intermediate steps can be displayed.
Continuous components are simulated using an off-the-shelf
numerical solvers (SUNDIALS
\footnoteurl{CVODE}{https://www.llnl.gov/casc/sundials/}~\cite{sundials:2005})
and, two built-in basic solvers (based on Matlab's \texttt{ode23} and
\texttt{ode45} solvers~\cite{ShampineGlaTho:ODEsMatlab:2003}).
%\footnote{The source-to-source translation of ODEs into synchronous data-flow
%equations is not done for the moment.}
\end{flatitemize}

\zelus{} is a research prototype that exhibits a new way of
defining a hybrid systems modeling language based on
the principles and techniques of synchronous languages.
Its expressive power for modeling physics is limited to ODEs, unlike 
\footnoteurl{\modelica}{https://www.modelica.org} which is based on DAEs.
%Its expressive power for modeling physics
%is limited to ODEs and not DAEs as
%\modelica~\footnote{\url{https://www.modelica.org}} does.
Research papers on the design, semantics and implementation of \zelus{} are 
available at \url{http://zelus.di.ens.fr}.

\section*{Availability\label{availability}}
The implementation is written in, and generates programs in \ocaml, which 
must be installed.
\begin{center}
\begin{tabular}{ll}
  \zelus, version 1.2:  & \url{http://zelus.di.ens.fr} \\
  Objective Caml, version 4.02.1  & \url{http://www.ocaml.org}
%   \\
%   SundialsML & \\url{http://inria-parkas.github.io/sundialsml/}
%   \\
%   SUNDIALS & \url{https://computation.llnl.gov/casc/sundials/}
\end{tabular}
\end{center}
The language is experimental and evolves continuously. Please send
comments or bug reports to \mailto{Timothy.Bourke@inria.fr} or 
\mailto{Marc.Pouzet@ens.fr}. 

\section*{Copyright notice\label{copyright}}
This software includes the \ocaml{} run-time system, which is
copyrighted INRIA, 2015. 

\section*{Thanks\label{thanks}}

This software is a research prototype that takes considerable time to 
develop.
If you find it useful, please consider citing our work~\cite{lucy:hscc13} 
and sending us comments.

% }-}1
\cleardoublepage
\part{The Z\'elus Language\label{zeluslang}}
\cleardoublepage
\chapter{Synchronous Programming\label{syncprog}} %{-{1
%HEVEA\cutdef[1]{section}
%{-{2

This chapter and the next one give a tutorial introduction to \zelus. This
chapter focuses on the synchronous kernel of the language, which is 
reminiscent of \lustre{} and \lucy.
We shall sometimes compare \zelus{} with those two languages.
The next chapter focuses on newer, hybrid aspects, like ODEs,
zero-crossings, and their interaction with the synchronous features.
The simulation engine is described in \cref{compilsimul}.

Familiarity with general programming languages is assumed.
Some familiarity with (strict or lazy) ML
languages and with existing synchronous data-flow languages like \lustre{} is
helpful but not mandatory. Some references are given at the end of this document.

In this tutorial, we suppose that programs are written in a file called
\verb-tutorial.zls-.% This file is available in the \zelus{} distribution.

% }-}2
\section{The Core Synchronous Language\label{coresync}} %{-{2
%We start with the synchronous part of the language. ODEs and all continuous
%aspect are considered later.

\subsection{Point-wise Operations\label{pointwise}} %{-{3

\zelus{} is a first-order functional language. As in \lustre,
every ground type or scalar value is imported from a host language
(\ocaml{}) and implicitly lifted to signals. A signal is a
\emph{sequence} or \emph{stream} of values ordered in time:
a value at an instant can only be produced after the values at all previous 
instants have been produced. This property
models \emph{causality}. In particular,
\begin{itemize}
\item \zls{int} stands for the type of streams of integers,
\item \zls{1} stands for the constant stream of $1$s,
\item \zls{+} stands for the pointwise addition operator over two input 
streams. It can be seen as an adder circuit just as \zls{\&\&} can be seen 
as an ``and'' gate.
\end{itemize}
Program executions can be represented as \emph{timelines} showing the 
sequences of values taken by streams. The
example below shows five streams, one per line. The first line shows
a stream \zls{c}, which has the value \t{} ({\em true}) at the first 
instant, \f{} ({\em false}) at the second one, and \t{} at the
third. The `$\cdots$' indicates that the stream has infinitely more values 
that are not shown. The next two lines define \zls{x} and \zls{y}. The 
fourth line defines a stream obtained
by the pointwise addition of \zls{x} and \zls{y}.
The expression in the fifth line takes the current value of either \zls{x} 
or \zls{y} according to the current value of \zls{c}.

\begin{chrono}{c|cccc}
\hline
\zls{c} & \T & \F & \T & $\cdots$ \\ \hline
\zls{x} & $x_0$ & $x_1$ & $x_2$ & $\cdots$ \\ \hline
\zls{y} & $y_0$ & $y_1$ & $y_2$ & $\cdots$ \\ \hline
\zls{x+y} & $x_0 + y_0$ & $x_1 + y_1$ & $x_2 + y_2$ & $\cdots$ \\
\hline \zls{if c then x else y} &  $x_0$ & $y_1$ & $x_2$ & $\cdots$ \\ 
\hline
\end{chrono}

% }-}3
\subsection{Delays\label{delays}} %{-{3

The delay operator is denoted \zls{fby}.
The expression \zls{x fby y}, which is read as ``\zls{x} {\em followed by} 
\zls{y}'' takes the first value
of \zls{x} at the first instant and the previous value of \zls{y} at all 
instants thereafter. In other words, it delays \zls{y} by one instant, and 
is initialized by \zls{x}.
This operator originated in the language \lucid~\cite{lucida}.
\begin{chrono}{c|cccc}
\hline
\zls{x} & $x_0$ & $x_1$ & $x_2$ & $\cdots$ \\ \hline
\zls{y} & $y_0$ & $y_1$ & $y_2$ & $\cdots$ \\ \hline
\zls{x fby y} &  $x_0$ & $y_0$ & $y_1$ & $\cdots$ \\ \hline
\end{chrono}
As it is often useful to separate a delay from its initialization, there is 
an operator \zls{pre x} that delays its argument \zls{x} and has an
unspecified value (denoted here by \nil{}) at the first instant.
The complementary initialization operator  \zls{x -> y} takes the first 
value of \zls{x} at the first instant, and the current value of \zls{y} 
thereafter.
The expression \zls{x -> (pre y)} is equivalent to \zls{x fby y}.
\begin{chrono}{c|cccc}
\hline
\zls{x} & $x_0$ & $x_1$ & $x_2$ & $\cdots$ \\ \hline
\zls{y} & $y_0$ & $y_1$ & $y_2$ & $\cdots$ \\ \hline
\zls{pre x} &  \nil & $x_0$ & $x_1$ & $\cdots$ \\ \hline
\zls{x -> y} &  $x_0$ & $y_1$ & $y_2$ & $\cdots$ \\ \hline
\end{chrono}
The compiler performs an {\em initialization check} to ensure that the
behavior of a program never depends on the value \nil. See
\cref{initcheck} for details.

\paragraph{Note:} A common error is to try to use the initialization 
operator to define the first two values of a
stream. This does not work, since \zls{x -> y -> z} =
\zls{x -> z}. One should instead write either \zls{x fby y fby z} or
\zls{x -> pre (y -> pre z)}.
For example, the stream which starts with a value
$1$, followed by a $2$, and then $3$ forever is written \zls{1 fby 2 fby 3}
or \mbox{\zls{1 -> pre(2 -> pre(3))}} or \zls{1 -> pre(2 -> 3)}.

% }-}3
\subsection{Global Declarations\label{globaldecl}} %{-{3

A program is a sequence of declarations of global
values. The keyword \zls{let} defines non recursive global values which may
be either constants or functions. For example:
\begin{chklisting}
let dt = 0.001
let g = 9.81
\end{chklisting}
These declarations define two constant streams \zls{dt} and
\zls{g}.
Given the option \texttt{-i}, the compiler displays the types inferred for 
each declaration:
\begin{sample}\chklistingcmd\end{sample}
\chklistingmsg{}
Only constant values can be defined globally.
The declaration
\begin{chklisting}[fail]
let first = true -> false
\end{chklisting}
is rejected with the message:
\begin{sample}\chklistingcmd\end{sample}
\chklistingerr{}
The right-hand side of a global \zls{let} declaration may not contain delay 
operations. Definitions containing delays require the introduction of state.
They may only be made within the \zls{node} definition described 
in~\cref{nodefunc}.

% }-}3
\subsection{Combinatorial Functions\label{combfunc}} %{-{3

Functions whose output at an instant depends only on inputs at the same 
instant are termed \emph{combinatorial}.
They are stateless and may thus be used in both discrete and continuous 
time.
Any expression without delays, initialization operators, or automata is 
necessarily combinatorial.
%Signal functions can be {\em combinatorial} or not.
%A function is combinatorial when its output at
%instant $n$ depends only on its input at the same instant $n$.
%Combinatorial
%functions are stateless and can thus be used at any time scale, either
%discrete or continuous.

As for any globally defined value, a combinatorial function
is defined using the \zls{let} keyword.
Consider, for example, a function computing the
instantaneous average of two inputs:
\begin{chklisting}[withresult]
let average (x,y) = (x + y) / 2
\end{chklisting}
The type signature inferred by the compiler, \zlsmsg{int * int -A-> int},
indicates that it takes two integer streams and returns an integer stream.
The arrow \texttt{-A->} tagged with an \AnyKind{} indicates that this 
function is combinatorial.
The \AnyKind{} stands for ``any''---the function \zls{average} can be used 
anywhere in the code.
We will describe other possibilities soon.

Function definitions may contain local declarations, introduced using
either \zls{where} or \zls{let} notations. For example, the average function 
can be written in two (equivalent) ways:
\begin{chklisting}
let average (x,y) = o where o = (x + y) / 2
\end{chklisting}
and
\begin{chklisting}
let average (x,y) = let o = (x + y) / 2 in o
\end{chklisting}

The full adder is a classic example of a combinatorial program.
%As another example of a combinatorial program, we end with the classical
%description of a one-bit adder
It takes three input bits, \zls{a}, \zls{b}, and a carry bit \zls{c}, and 
returns outputs for the sum~\zls{s} and carry-out~\zls{co}.
\begin{chklisting}[withresult,label=xor]
let xor (a, b) = (a & not(b)) or (not a & b)

let full_add (a, b, c) = (s, co) where
       s = xor (xor (a, b), c)
   and co = (a & b) or (b & c) or (a & c)
\end{chklisting}

\begin{figure}
\centering %{-{4
\begin{tikzpicture}[
    circuit logic US,
    every circuit symbol/.style={draw,thick},
    wire/.style={thick},
    every node/.style={font=\sffamily\footnotesize},
    connector/.style={fill,circle,inner sep=1pt},
    node distance=.5cm,
]
\begin{scope}
    \node [xor gate] (s) {};
    \node [and gate,below right=of s] (co) {};
    \draw[wire]
        (s.input 1)
        -- ++(left:.8cm) coordinate (a) node[left,yshift=1] {a}
        (s.input 2)
        -- (s.input 2 -| a) coordinate (b) node[left,yshift=-1] {b}
        (co.input 1) -| ($ (a)!.7!(s.input 1) $) node[connector] {}
        (co.input 2) -| ($ (b)!.3!(s.input 2) $) node[connector] {}
        (s.output) -- (right:1.7cm) coordinate (s out) node[right] {s}
        (co.output) -- (co.output -| s out) node[right] {co}
    ;
\end{scope}

\begin{scope}[xshift=4.5cm]
    \node [xor gate] (s1) {};
    \node [and gate,below right=of s1] (c1) {};
    \draw[wire]
        (s1.input 1)
        -- ++(left:.8cm) coordinate (a) node[left,yshift=1] {a}
        (s1.input 2)
        -- (s1.input 2 -| a) coordinate (b) node[left,yshift=-1] {b}
        (c1.input 1) -| ($ (a)!.7!(s1.input 1) $) node[connector] {}
        (c1.input 2) -| ($ (b)!.3!(s1.input 2) $) node[connector] {}
    ;

    \node [xor gate,above right=1cm and 2.0cm of s1.output] (s2) {};
    \node [and gate,below right=of s2] (c2) {};
    \node [or gate,right=1cm of c2,anchor=input 1] (co) {};
    \draw[wire]
        (s2.input 1) -- ++(left:.8cm) coordinate (c) node[left,yshift=1] {c}
        (s2.input 2) -- ++(left:1.2cm) coordinate (s2 bend) node[left] {s1}
        (c2.input 1) -| ($ (c)!.7!(s2.input 1) $) node[connector] {}
        (c2.input 2) -| ($ (s2 bend)!.3!(s2.input 2) $) node[connector] {}
        (c2.output) -- node[above,near start] {c2} (co.input 1)
        (co.input 2) -- ++(left:.5cm) |- (c1.output) node[above right] {c1}
        (co.output) -- ++(right:.5cm) coordinate (co) node[right] {co}
        (s1.output) -| (s2 bend)
        (s2.output) -- (s2.output -| co) node[right] {s}
    ;
\end{scope}
\end{tikzpicture} % }-}4
\caption{A half-adder and a full-adder\label{half-adder}}
\end{figure}

Alternatively, a full adder can be described more efficiently as a 
composition
of two half adders. A graphical depiction is given in
\cref{half-adder}. The corresponding program text is:
\begin{chklisting}[continue,withresult]
let half_add(a,b) = (s, co) where
       s = xor (a, b)
   and co = a & b
\end{chklisting}
%
\begin{chklisting}[continue,withresult]
let full_add2(a, b, c) = (s, co) where
  rec (s1, c1) = half_add(a, b)
  and (s, c2) = half_add(c, s1)
  and co = c1 or c2
\end{chklisting}

The \zls{rec} keyword specifies that the block of equations following the 
\zls{where} is defined by mutual recursion.
Without it, the \zls{s1} in the equation for \zls{s} and \zls{c2} would have 
to exist in the list of inputs or the global environment, and similarly for 
\zls{c1} and \zls{c2} in the equation for \zls{co}.

\paragraph{Alternative notation:} For combinatorial function definitions, 
the keyword \zls{let} can be replaced by \zls{fun}.
\begin{chklisting}[include=xor]
fun half_add (a,b) = (s, co) where
  rec s = xor (a, b)
  and co = a & b
\end{chklisting}

% }-}3
\subsection{Stateful Functions\label{nodefunc}} %{-{3

A function is stateful or \emph{sequential} if its output at an instant~$n$ 
depends on the inputs at previous instants~$k$ ($k \leq n$), that is, on the 
history of inputs.
Such functions may produce a varying output signal even when their inputs 
are constant.
%Stateful or \emph{sequential} functions are
%such that their output
%at some instant $n$ may depend on the history of their inputs, that is,
%input values of instants $k$ ($k \leq n$).
%A function is called
%sequential if it may produce a non constant output signal even when its
%inputs are constant. Otherwise, we call it combinatorial.
%A
%sufficient condition to be a combinatorial expression is not to
%contain any delay, initialization operator, nor automaton.

Stateful functions must be declared with the \zls{node} keyword.
For example, this function computes the sequence of integers starting at an 
initial value given by the parameter \zls{m}:
\begin{chklisting}[withresult]
let node from m = nat where
  rec nat = m -> pre nat + 1
\end{chklisting}

\noindent
The type signature \zlsmsg{int -D-> int} indicates that \zls{from} is
a sequential function that maps one integer stream to another.
The \zls{D} indicates that this function is stateful, it stands for 
``discrete''.
The function's output may depend on the past values of its input.

Applying this function to the constant stream \zls{0} yields the
execution:
\begin{chrono}{l|ccccccc}
\hline
\zls{m}                 & 0    & 0 & 0 & 0 & 0 & 0 & $\cdots$ \\ \hline
\zls{1}                 & 1    & 1 & 1 & 1 & 1 & 1 & $\cdots$ \\ \hline
\zls{pre nat}           & \nil & 0 & 1 & 2 & 3 & 4 & $\cdots$ \\ \hline
\zls{pre nat + 1}       & \nil & 1 & 2 & 3 & 4 & 5 & $\cdots$ \\ \hline
\zls{m -> pre nat + 1}  & 0    & 1 & 2 & 3 & 4 & 5 & $\cdots$ \\ \hline
\zls{from m}            & 0    & 1 & 2 & 3 & 4 & 5 & $\cdots$ \\ \hline
\end{chrono}

The fact that a function is combinatorial is verified during compilation.
Thus, omitting the \zls{node} keyword,
\begin{chklisting}[fail]
let from n = nat where rec nat = n -> pre nat + 1
\end{chklisting}
leads to an error message:
\begin{sample}\chklistingcmd\end{sample}
\chklistingerr{}
While a node (arrow type \zlsmsg{-D->}) cannot be called within a 
combinatorial function, it is possible to call a combinatorial function
(arrow type \zlsmsg{-A->}) within in a
node. For example, the addition operator in the \zls{from} function has the 
type signature \zlsmsg{int * int -A-> int}.

We now present a few more examples of stateful functions.

The edge front detector is defined as a global function from boolean streams 
to boolean streams:%
\begin{chklisting}[withresult]
let node edge c = c & not (false fby c)
\end{chklisting}
\begin{chrono}{l|ccccccc}
\hline
\zls{c}                 & \F & \F & \T & \T & \F &  \T & $\cdots$ \\ \hline
\zls{false}             & \F & \F & \F & \F & \F &  \F & $\cdots$ \\ \hline
\zls{false fby c}       & \F & \F & \F & \T & \T &  \F & $\cdots$ \\ \hline
\zls{not (false fby c)} & \T & \T & \T & \F & \F &  \T & $\cdots$ \\ \hline
\zls{edge c}            & \F & \F & \T & \F & \F &  \T & $\cdots$ \\ \hline
\end{chrono}

\medskip\noindent
A forward Euler integrator can be defined by:
\begin{chklisting}[withresult,label=integr]
let dt = 0.01
let node integr (x0, x') = x where
  rec x = x0 -> pre (x +. x' *. dt)
\end{chklisting}
These declarations give a global function \zls{integr} that returns a stream 
\zls{x} defined
recursively so that, for all $n \in \Nat, x(n) = x0 + \sum_{i=0}^{n-1}
x'(i)\cdot dt$.  The operators `\zls{+.}' and `\zls{*.}' are, respectively, 
addition and multiplication over floating-point numbers. Stateful
functions are composed just like any other functions, as, for example, in:
\begin{chklisting}[continue]
let node double_integr (x0, x0', x'') = x where
  rec x = integr (x0, x')
  and x' = integr (x0', x'')
\end{chklisting}

\paragraph{Alternative notation:}
The keyword \zls{let} can be omitted, for example,
\begin{chklisting}[skipone]
let dt = 0.01
node integr (x0, x') = x where
  rec x = x0 -> pre (x +. x' *. dt)
\end{chklisting}


% \subsection{Anonymous Functions}
% Functions can be defined in an anonymous way and can be used as
% values. Anonymous combinatorial functions are introduced using a
% single arrow ({\tt ->}), anonymous sequential ones using a double
% arrow ({\tt =>}). For example, the expression \verb#fun x y -> x + y#
% is the sum function and has type \verb#int -> int -> int#). The
% expression \verb#fun x y => x fby x fby y# defines a double delay and
% has the type \verb#'a -> 'a => 'a#.

% The functions \verb-average- and \verb-from- can be defined as:
% \begin{chklisting}
% let average = fun (x,y) -> (x + y) / 2
% let from = fun n => nat where rec nat = n -> pre nat + 1
% \end{chklisting}

% }-}3
\subsection{Local and Mutually Recursive Definitions\label{localdefmut}} %{-{3

Variables may be defined locally with \zls{let}/\zls{in} or
\zls{let rec}/\zls{in} whether the defining expression is stateful or not.
The following
program computes the Euclidean distance between two points:%
\begin{chklisting}
let distance ((x0,y0), (x1,y1)) =
  let d0 = x1 -. x0 in
  let d1 = y1 -. x1 in
  sqrt (d0 *. d0 +. d1 *. d1)
\end{chklisting}
Since \zls{d0} and \zls{d1} denote infinite streams, the computations of 
\zls{x1 -. x0} and \zls{y1 -. x1} occur in parallel, at least conceptually.
In \zelus, however, the consecutive nesting of \zls{let}/\zls{in}s 
introduces a sequential ordering on the computations at an instant.
In this example, this means that the current value of \zls{d0} is always 
computed before the current value of \zls{d1}.
Being able to impose such an ordering is useful when functions with 
side-effects are imported from the host language.
Write simply \zls{let rec d0 = ... and d1 = ...} if no particular ordering 
is needed.

Streams may be defined through sets of mutually recursive equations.  The
function that computes the minimum and maximum of an input stream
\zls{x} can be written in at least three equivalent ways.
As two mutually recursive equations after a \zls{where}:
\begin{chklisting}
let node min_max x = (min, max) where
  rec min = x -> if x < pre min then x else pre min
  and max = x -> if x > pre max then x else pre max
\end{chklisting}
as a stream of tuples defined by two local, mutually recursive equations:
\begin{chklisting}
let node min_max x =
  let rec min = x -> if x < pre min then x else pre min
      and max = x -> if x > pre max then x else pre max in
  (min, max)
\end{chklisting}
or as a stream of tuples defined by a single recursive equation:
\begin{chklisting}
let node min_max x = (min, max) where
  rec (min, max) = (x, x) -> if x < pre min then (x, pre max)
                             else if x > pre max then (pre min, x)
                             else (pre min, pre max)
\end{chklisting}

\noindent Discrete approximations to the sine and cosine functions can be 
defined by:
\begin{chklisting}[continue,include=integr]
let node sin_cos theta = (sin, cos) where
  rec sin = integr(0.0, theta *. cos)
  and cos = integr(1.0, -. theta *. sin)
\end{chklisting}

% }-}3
\subsection{Shared Memory and Initialization\label{sharedinit}} %{-{3

In addition to the delay operator \zls{pre}, \zelus{} provides another 
construction for referring to the previous value of a stream: \zls{last o}, 
where \zls{o} is a variable defined by an equation. For example:%
\begin{chklisting}
let node counter i = o where
  rec init o = i
  and o = last o + 1
\end{chklisting}
The equation \zls{init o = i} defines the initial value of the \emph{memory} 
\zls{last o}. This memory is initialized with the first
value of \zls{i} and thereafter contains the previous value of
\zls{o}. The above program is thus equivalent to the following
one:\footnote{The construction \zls{last} is eliminated during compilation 
by a similar transformation.}
\begin{chklisting}
let node counter i = o where
  rec last_o = i -> pre o
  and o = last_o + 1
\end{chklisting}
The reason for introducing memories will become clear when control 
structures are introduced in \cref{patternmatch}.
Syntactically, \zls{last} is {\em not} an operator: \zls{last o} denotes
a shared memory and the argument of \zls{last}, here \zls{o}, must be a 
variable name. Thus this program is rejected:
\begin{chklisting}[fail,withresult]
let node f () = o where
  rec o = 0 -> last (o + 1)
\end{chklisting}

Rather than define the current value of a signal in terms of its previous
one, the next value can also be defined in terms of the current one.
The same counter program can be written:
\begin{chklisting}
let node counter i = o where
  rec init o = i
  and next o = o + 1
\end{chklisting}
or equivalently:
\begin{chklisting}
let node counter i = o where
  rec next o = o + 1 init i
\end{chklisting}
In both definitions, \zls{o} is initialized with the first value of
\zls{i} and then the value of \zls{o} at instant $n+1$ is the value of
\zls{o + 1} at instant $n$ (for all $n \in \Nat$).

Neither the form defining the current value from the previous one, nor the 
form defining the next value from the current one is intrinsically superior; 
it depends on the situation.
Either form can be transformed into the other.
We will see in \cref{ode-programming} that restrictions apply to both the 
\zls{next} and \zls{last} constructions when combining discrete- and
continuous-time dynamics.

\Remark The compiler rewrites \zls{last}, \zls{->}, \zls{fby}, \zls{pre}, 
\zls{init} and \zls{next} into a minimal subset.

% }-}3
\subsection{Causality Check\label{causalcheck}} %{-{3

Instantaneous cycles between recursively defined values---\emph{causality 
loops}---are forbidden so that the compiler can produce statically-scheduled 
sequential code.
For example, the program:%
\begin{chklisting}[fail]
let node from m = nat where
  rec nat = m -> nat + 1
\end{chklisting}
is rejected with the message:
\chklistingerr{}
\noindent
This program cannot be computed since \zls{nat} depends instantaneously on 
itself.
The compiler statically rejects function definitions that cannot be 
scheduled sequentially, that is, when the value of a stream at an 
instant~$n$ may be required in the calculation of that very value at the 
same instant, whether directly or through a sequence of intermediate 
calculations.
In practice, we impose that all such stream interdependencies be broken by a 
delay (\zls{pre} or \zls{fby}).
The purpose of \emph{causality analysis} to to reject all other loops.

Note that delays can be hidden internally in the body of a function as
is the case, for instance, in the languages \lustre{} and \signal.
For example, consider the initial value problem:
\begin{align*}
\dot{t} &= g_0 - g_1 \cdot t \\
t(0) &= t_0
\end{align*}
We can approximate this value by using the explicit Euler integrator defined 
previously and defining a signal~$t$ by a recursive equation.
\begin{chklisting}[withresult,include=integr]
(* [t0] is the initial temperature; [g0] and [g1] two constants *)
let node heater(t0, g0, g1) = t where
  rec t = integr(t0, g0 -. g1 *. t)
\end{chklisting}
This feedback loop is accepted because \zls{integr(t0, g0 -. g1 *. temp)} 
does not depend instantaneously on its input.

It is also possible to force the compiler to consider a function as strict 
with the \zls{atomic} keyword. For example, the following program is
rejected by the causality analysis.
%
\begin{chklisting}[fail,withresult]
let atomic node f x = 0 -> pre (x + 1)
let node wrong () =
  let rec o = f o in o
\end{chklisting}
%
Even though the output of \zls{f} does not depend instantaneously
on its input \zls{x}, the keyword \zls{atomic} adds instantaneous 
dependencies between the output and all inputs.
For atomic functions, the compiler produces a single step
function.\footnote{Note, though, that Modular code generation
  where a function is split into a minimal set of functions, as
  proposed in~\cite{lucy:emsoft09,lustre:tripakis-popl09}, is not
  implemented in the current version of the compiler. Some functions
  are inlined, however, according to the dependency information
  computed by the causality analysis.}

%}-}3
\subsection{Initialization Check\label{initcheck}} %{-{3

The compiler checks that every delay operator is initialized. For
example,
\begin{chklisting}[fail,withresult]
let node from m = nat where
  rec nat = pre nat + 1
\end{chklisting}
The analysis~\cite{lucy:sttt04} is a {\em one-bit} analysis where 
expressions are considered to be either always defined or always defined 
except at the very first instant.
In practice, it rejects expressions like \zls{pre (pre e)}, that is,
uninitialized expressions cannot be passed as arguments to delays; they must 
first be initialized using the \zls{->} operator.

% }-}3
% }-}2
\section{Data types and Pattern Matching\label{dtypespatterns}} %{-{2
\subsection{Type Definitions\label{typedef}} %{-{3

Product types, record types, and enumerated types are defined in a syntax 
close to that of \ocaml.
Constructors with arguments are not supported in the current release.
They can nevertheless be defined together with the functions that manipulate 
them in an \ocaml{} module which is then imported into \zelus; see 
\cref{importing}.

Records are defined as in Ocaml and accessed with the dot notation. For 
example,
the following defines a type \zls{circle}, representing a circle as a record 
containing a \zls{center}, given by its coordinates, and a \zls{radius}.
\begin{chklisting}
type circle = { center: float * float; radius: float }

let center c = c.center
let radius c = c.radius
\end{chklisting}
  
% }-}3
\subsection{Pattern Matching\label{patternmatch}} %{-{3

Pattern matching over streams uses a \zls{match/with} construction like that 
of \ocaml.

For example, consider a colored wheel rotating on an axis for which we want 
to compute the direction of rotation.
As shown in \cref{colorwheel}, the wheel has three sections with colors, 
ordered clockwise, blue (\zls{Blue}), green (\zls{Green}), and red 
(\zls{Red}) .
A sensor mounted on the frame detects the changing colors as the wheel 
turns.

\begin{figure}[t]
\centering%{-{4
\begin{tikzpicture}[fill opacity=.7]
    \path[fill=blue]
        (0,0)
        -- (-15:1.5)
        arc (-15:105:1.5) coordinate (blue)
        -- cycle;
    \path[fill=red]
        (0,0)
        -- (blue)
        arc (105:225:1.5) coordinate (red)
        -- cycle;
    \path[fill=green]
        (0,0)
        -- (red)
        arc (225:345:1.5) coordinate (red)
        -- cycle;
    \draw[fill=black]
          (-.1,.9)
       -- ++(.2,0)
       -- ++(0,1.0) node[right] {sensor}
       -- ++(-.2,0)
       -- cycle;
    \fill[black] (0,0) circle (.1);
\end{tikzpicture} %}-}4
\caption{Rotating colored wheel and sensor\label{colorwheel}}
\end{figure}

We must calculate whether the wheel is moving clockwise (\zls{Clockwise}), 
that is, the sensor reports the sequence \zls{Red}, \zls{Green}, \zls{Blue}, 
\zls{Red}\ldots, anticlockwise (\zls{Anticlockwise}), whether it is not 
moving (\zls{Immobile}), or whether the direction cannot be determined 
(\zls{Undetermined}).
We program the controller by first introducing two sum types:
\begin{chklisting}
type color = Blue | Red | Green
type dir = Clockwise | Anticlockwise | Undetermined | Immobile
\end{chklisting}
The function \zls{direction} then compares three successive values of the 
input stream \zls{i}.
\begin{chklisting}[continue,withresult]
let node direction i = d where
  rec pi = i fby i
  and ppi = i fby pi
  and match ppi, pi, i with
      | (Red, Red, Red) | (Blue, Blue, Blue) | (Green, Green, Green) ->
             do d = Immobile done
      | (_, Blue, Red) | (_, Green, Blue) | (_, Red, Green) ->
             do d = Clockwise done
      | (_, Red, Blue) | (_, Green, Red) | (_, Blue, Green) ->
             do d = Anticlockwise done
      | _ -> do d = Undetermined done
  end
\end{chklisting}

Each handler in a pattern-matching construct contains a set of
equations defining \emph{shared} variables; here the variable
\zls{d}.
At each instant, the \zls{match/with} statement in the example selects
the first pattern (from the top) that matches the actual value
of the triple \zls{ppi, pi, i} and executes the corresponding
branch.
Only one branch is executed in any single reaction.

Combining such control structures with delay operators can give rise to 
subtle behaviors.
Consider, for instance, the following program with two modes: in the 
\zls{Up} mode, the variable \zls{o} increases by \zls{1} at each reaction 
and, in the mode \zls{Down}, it decreases by \zls{1}.
\begin{chklisting}
type modes = Up | Down

let node two (m, i) = o where
  rec init o = i
  and match m with
      | Up -> do o = last o + 1 done
      | Down -> do o = last o - 1 done
      end
\end{chklisting}
The equation \zls{init o = i} defines a shared memory \zls{last o}
which is initialized with the first value of \zls{i}.
The variable \zls{o} is called a \emph{shared variable} because its 
definition is spread over several equations: when \zls{m} equals \zls{Up}, 
\zls{o} equals \zls{last o + 1}; when \zls{m} equals \zls{Down}, \zls{o} 
equals \zls{last o - 1}.
Communication between the two modes occurs through the shared memory 
\zls{last o} which contains the value that \zls{o} had the last time that it 
was defined (that is, at the most recent previous instant of definition).
An example execution diagram is given below.
\begin{chrono}{l|cccccccc}
\hline
\tt i                 & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & $\cdots$ \\
\hline
\tt m                 & \tt Up & \tt Up & \tt Up & \tt Down & \tt Up & \tt Down &  \tt Down & $\cdots$ \\
\hline
\tt last o + 1        & \tt 1  & \tt 2  & \tt 3  &          & \tt 3  &       & 
& $\cdots$ \\
\hline
\tt last o - 1        &        &        &        & \tt 2    &        & \tt 2 &  \tt 1   & $\cdots$ \\
\hline
\tt o                 & \tt 1  & \tt 2  & \tt 3    & \tt 2    & \tt 3  & \tt 2    &  \tt 1  & $\cdots$ \\
\hline
\tt last o            & \tt 0  & \tt 1  & \tt 2    & \tt 3  & \tt 2    &  \tt 3  & \tt 2 & $\cdots$ \\
\hline
\end{chrono}

\medskip\noindent
An equivalent way to express the same behaviour is:
\begin{chklisting}[hide,label=updownmodes]
type modes = Up | Down
\end{chklisting}
\begin{chklisting}[continue]
let node two (m, i) = o where
  rec last_o = i -> pre o
  and match m with
      | Up -> do o = last_o + 1 done
      | Down -> do o = last_o - 1 done
      end
\end{chklisting}
This version makes it clear how \zls{last o} stands for the previously 
defined value of \zls{o}.

The next section explains why using \zls{pre} in this example would have 
given quite different results.

% }-}3
\subsection{Pre versus Last\label{prelast}} %{-{3

While \zls{last o} may seem like just an alternative to \zls{pre o} for 
referring to the previous value of a stream, there is a fundamental 
difference between the two based on their respective instants of 
observation.

\begin{flatitemize}
\item
In \zelus{}, as in other block-diagram formalisms like \simulink{} and 
\scade, \zls{pre e} is a unit delay through a local memory---it denotes the 
value that its argument had the last time it was \emph{observed}.
If \zls{pre e} is used in a block structure which is executed from time to 
time, for example, when some condition \zls{c} is true, the argument~\zls{e} 
is only computed when~\zls{c} is true: \zls{pre e} is the value of \zls{e} 
the last time \zls{c} was true.

\item
On the other hand, \zls{last o} denotes the previous value of the variable 
\zls{o} relative to the sequence of instants where the variable \zls{o} (it 
must be a variable and not an expression) is \emph{defined}.
It is useful for communicating values between modes which is why it is 
called a shared memory.
\end{flatitemize}

We augment the previous example with extra equations to illustrate the 
difference between the two delay constructs.
The two new streams \zls{c1} and \zls{c2} return respectively the number of 
instants in which each mode is active.
\begin{chklisting}[include=updownmodes]
let node two (m, i) = (o, c1, c2) where
  rec init o = i
  and init c1 = 0
  and init c2 = 0
  and match m with
       | Up -> do o = last o + 1
               and c1 = 1 -> pre c1 + 1
               done
       | Down -> do o = last o - 1
                 and c2 = 1 -> pre c2 + 1
                 done
    end
\end{chklisting}
%
The equation \zls{c1 = 1 -> pre c1 + 1} is only active in the
\zls{Up} mode, and the equation \zls{c2 = 1 -> pre c2 + 1} is
only active in the \zls{Down} mode. The execution diagram is given below.
\begin{chrono}{l|cccccccc}
\hline
\tt i                 & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & $\cdots$ \\
\hline
\tt m                 & \tt Up & \tt Up & \tt Up & \tt Down & \tt Up & \tt Down &  \tt Down & $\cdots$ \\
\hline
\tt last o + 1        & \tt 1  & \tt 2  & \tt 3  &          & \tt 3  &       & 
& $\cdots$ \\
\hline
\tt 1 -> pre c1 + 1   & \tt 1  & \tt 2  & \tt 3  &          & \tt 4  &       & 
& $\cdots$ \\
\hline
\tt last o - 1        &        &        &        & \tt 2    &        & \tt 2 &  \tt 1   & $\cdots$ \\
\hline
\tt 1 -> pre c2 + 1   &        &        &        & \tt 1    &        & \tt 2 &  \tt 3   & $\cdots$ \\
\hline
\tt o                 & \tt 1  & \tt 2  & \tt 3    & \tt 2    & \tt 3  & \tt 2    &  \tt 1  & $\cdots$ \\
\hline
\tt last o            & \tt 0  & \tt 1  & \tt 2    & \tt 3  & \tt 2    &  \tt 3  & \tt 2 & $\cdots$ \\
\hline
\tt c1                 & \tt 1  & \tt 2  & \tt 3    & \tt 3    & \tt 4  & \tt 4    &  \tt 4  & $\cdots$ \\
\hline
\tt c2                 & \tt 0  & \tt 0  & \tt 0    & \tt 1    & \tt 1  & \tt 2    &  \tt 3  & $\cdots$ \\
\hline
\end{chrono}

Pattern matching composes complementary sub-streams.
For instance, the \zls{match/with} in the previous example has two branches, 
and each defines its own clock, one for the instants when \zls{m = Up} and 
the other for the instants when \zls{m = Down}.

% }-}3
\subsection{Local Definitions\label{localdef}} %{-{3

It is possible to define variables which are local to a branch. For
example:
\begin{chklisting}[include=updownmodes]
let node two (m, i) = o where
  match m with
  | Up -> let rec c = 0 -> pre c + 1 in
          do o = c done
  | Down -> do o = 0 done
  end
\end{chklisting}
or equivalently:
\begin{chklisting}[include=updownmodes]
let node two (m, i) = o where
  match m with
  | Up -> local c in
          do c = 0 -> pre c + 1
          and o = c done
  | Down -> do o = 0 done
  end
\end{chklisting}
Here, \zls{c} is declared local to the first handler of the \zls{match/with} 
statement.
The compiler verifies that a definition for \zls{c} is given.
Several variables can be declared local by writing
\zls{local c1,..., cn in ...}.

% }-}3
\subsection{Implicit Completion of Shared Variables\label{completeshared}} %{-{3

The branches of a pattern-matching construct need not contain definitions 
for all shared variables.
Branches without a definition for a shared variable \zls{o} are implicitly 
\emph{completed} with an equation \zls{o = last o}.

The compiler rejects programs where it is unable to ensure that \zls{last o} 
has an initial value.
The following program, for instance, is rejected.
\begin{chklisting}[withresult,fail,include=updownmodes]
let node two (m, i) = o where
  rec match m with
      | Up -> do o = last o + 1 done
      | Down -> do o = last o - 1 done
      end
\end{chklisting}

% \begin{verbatim}
% type event = Click | Move | Keypressed of char

% (* count the number of Move between two click *)
% let node count e = cpt where
%   rec last o = 0
%   and match e with
%         Top -> do o = last o + 1 done
%       | Click -> do o = last o done
%       end
% \end{verbatim}

% A pattern matching composes several complementary sub-streams, that
% is, streams on complementary clocks. The above pattern matching 
% has two branches. Every branch defines its own clock, one denoting
% the instants where \zls{e = Top} and the other denoting the instant
% where \zls{e = Click}.

% The branch \zls{Top when clk -> (pre o) when clk + 1}
% states that for the instants where the condition \zls{e = Top} is
% true (\zls{clk} being the clock of this branch), the result is the
% previous value of \zls{o} plus one. For the instants where
% \zls{e = Click}, the result is \zls{0}.

% The pattern-matching construction is very similar to the \zls{merge}
% construction and thus, benefit (and somethimes suffers ?) from the same clock
% constraints. Thus, writing simply \zls{(pre o) + 1} would lead to a
% clocking error since \zls{o} is on the base clock and must be sampled
% on the clock of the branch.

% The execution diagram is given below.

% \vspace{.5cm}

% \begin{tabular}
% {c|ccccccc}
% \hline
% \tt e                 & \tt Click & \tt Top & \tt Top & \tt Click & \tt Top &  \tt Click & \dots \\
% \hline
% \tt clk		      & $f$   & $t$ & $t$ & $f$   & $t$ &  $f$ & \dots \\
% \hline
% \tt Top when clk      &       & \tt Top & \tt Top &       & \tt Top &      & \dots \\
% \hline
% \tt (pre o) when clk + 1
%                       &       & $1$ & $2$ &       & $1$ &      & \dots \\
% \hline
% \tt Click             & \tt Click   &   &  & \tt Click   &   &  \tt Click & \dots \\
% \hline
% \tt 0                 & $0$   &  &  & $0$   &  &  $0$ & \dots \\
% \hline
% \tt o                 & $0$   & $1$ & $2$ & $0$   & $1$ &  $0$ & \dots \\
% \hline
% \end{tabular}

% \vspace{.5cm}

% This program can also be written in the following way:
% \begin{verbatim}
% let count e =
%   let rec o =
%     0 -> match e, pre o with
%       Top, o -> o + 1
%     | _ -> 0 in
%   o
% \end{verbatim}

% If we get back to the first version of the \zls{count} function, the reader may
%  notice the difference between an expression
% \zls{(pre o) when clk} which refers to ``the value of \zls{o} at the last
% global instant'' and \zls{pre (o when clk)} which refers ``the value
% of \zls{o} at the last instant where \zls{clk} was true''. To illustrate
% this difference, consider now the problem of counting the distance
% made by a mouse between two clicks.

% \begin{verbatim}
% (* computes the distance between two click *)
% let distance pos_x e =
%   0 -> match e with
%     Click when c -> pos_x when c - pre (pos_x when c)
%   | Top -> 0

% (* second way *)
% let distance d e =
%   0 -> match e, d with
%     Click, d -> d - pre d
%   | _ -> 0
% \end{verbatim}
% The execution diagram is given below.

% \vspace{.5cm}

% \begin{tabular}
% {c|ccccccc}
% \hline
% \tt pos\_x                 & $1$       & $2$     & $3$     & $3$       & $3$ &  $5$ & \dots \\
% \hline
% \tt e                 & \tt Click & \tt Top & \tt Top & \tt Click & \tt Top &  \tt Click & \dots \\
% \hline
% \tt Click when c      & \tt Click   &  & & \tt Click      & &  \tt Click  & \dots \\
% \hline
% \tt pos\_x when c     & $1$       &     &     & $3$       &  &  $5$ & \dots \\
% \hline
% \tt pre (pos\_x when c) & $nil$   &     &     & $1$       &  &  $3$ & \dots \\
% \hline
% \tt pos\_x when c -
% pre (pos\_x when c)      & $nil$  &     &     & $2$       &  &  $2$ & \dots \\
% \hline
% \tt distance d e       & $0$       & $0$&     & $2$        & $0$ & $2$ & \dots \\
% \hline
% \end{tabular}

% \vspace{.5cm}
% The \zls{match/with} construction is a generalised form of
% \zls{merge}. These constructions are the natural way to express
% control structure in a data-flow language. In the example above, the
% computation  
% \verb+pos_x when c - pre (pos_x when c)+ is only executed when
% \zls{e} equals \zls{Click}. The compilers deeply rely on clocks for
% generating good imperative code.

% }-}2
\section{Valued Signals\label{signals}} %{-{2
% {-{3

\zelus{} provides \emph{valued signals} that are built and accessed, 
respectively, through the constructions \zls{emit} and \zls{present}.
At every instant, a valued signal is a pair comprising (1) a boolean
$c$ indicating when the signal is present and (2) a value that is present 
when $c$ is true.\footnote{For \ocaml{} programmers: signals are like 
streams of an option type.}
 
% }-}3
\subsection{Signal Emission\label{emit}} %{-{3

Unlike shared variables, signal values are not necessarily defined at every 
instant, nor do they implicitly keep their previous value when not updated.
% As opposed to shared variables, it is now possible to give a
% partial definition with no implicit completion.
Consider this program, for instance:
\begin{chklisting}[withresult]
let node within (min, max, x) = o where
  rec c = (min <= x) & (x <= max)
  and present c -> do emit o = () done
\end{chklisting}
It computes a condition \zls{c} based on the input \zls{x}.
The signal \zls{o} is present with value \zls{()} every time \zls{c} is
true.
There is no need to give an initial value for \zls{o}.
When \zls{c} is false, \zls{o} is simply absent.
Removing the \zls{emit} gives a program that the compiler rejects:
\begin{chklisting}[withresult,fail]
let node within (min, max, x) = o where
  rec c = (min <= x) & (x <= max)
  and present c -> do o = () done
\end{chklisting}
The output \zls{o} is not declared as a shared variable (with \zls{init}) 
nor is it defined as a signal (with \zls{emit}).

% }-}3
\subsection{Signal Presence and Values\label{signalpresence}} %{-{3

The presence of a signal expression~\zls{e} can be tested by the boolean 
expression~\zls{?e}.
The following program, for
example, counts the number of instants where \zls{x} is emitted.
\begin{chklisting}[withresult]
let node count x = cpt where
  rec cpt = if ?x then 1 -> pre cpt + 1 else 0 -> pre cpt
\end{chklisting}

There is also a more general mechanism to test signal presence that treats 
multiple signals simultaneously and allows access to their values.
It resembles the pattern-matching construct of ML and it only allows signal 
values to be accessed at instants of emission.\footnote{Unlike in \esterel{} 
where signal values are maintained implicitly and can be accessed even in 
instants where they are not emitted.
The approach of \zelus{} is slightly more cumbersome, but it is safer and 
avoids initialization issues and the allocation of a state variable.}

The program below has two input signals, \zls{x} and \zls{y}, and
returns the sum of their values when both are emitted, the value of \zls{x} 
when it alone is emitted, the value of \zls{y} when it alone is emitted, and 
\zls{0} otherwise.
\begin{chklisting}[withresult]
let node sum (x, y) = o where
  present
  | x(v) & y(w) -> do o = v + w done
  | x(v) -> do o = v done
  | y(w) -> do o = w done
  else do o = 0 done
  end
\end{chklisting}
A \zls{present} statement comprises several signal patterns and handlers.
The patterns are tested sequentially from top to bottom.
The signal condition \zls{x(v) \& y(w)} matches when both \zls{x} and 
\zls{y} are present.
The condition \zls{x(v)} means ``\zls{x} is present and
has some value \zls{v}''.
When \zls{x} is present, the variable \zls{v} is bound to its value in the 
corresponding handler.

In the signal pattern \zls{x(v) \& y(w)}, \zls{x} and \zls{y} are
expressions that evaluate to signal values and \zls{v} and \zls{w}
are patterns. Writing \zls{x(42) \& y(w)} means ``detect the presence of 
signal \zls{x} with value \zls{42} and the simultaneous presence of 
\zls{y}''.

The output of the preceding function is a regular stream since the test is 
exhaustive thanks to the \zls{else} clause.
Omitting this default case results in an error.
\begin{chklisting}[withresult,fail]
let node sum (x, y) = o where
  present
  | x(v) & y(w) -> do o = v + w done
  | x(v1) -> do o = v1 done
  | y(v2) -> do o = v2 done
  end
\end{chklisting}
This error is easily eliminated by giving a last value to \zls{o}---for 
example, by adding the equation \zls{init o = 0} outside the present
statement. The default case is then implicitly completed with \zls{o = last 
o}.
Another way is to state that \zls{o} is a signal and thus only partially 
defined.
\begin{chklisting}[withresult]
let node sum (x, y) = o where
  present
  | x(v) & y(w) -> do emit o = v + w done
  | x(v1) -> do emit o = v1 done
  | y(v2) -> do emit o = v2 done
  end
\end{chklisting}

Signal patterns may also contain boolean expressions.
The following program adds the values of the two signals \zls{x} and \zls{y}
if they are emitted at the same time and if \zls{z >= 0}.
\begin{chklisting}
let node sum (x, y, z) = o where
  present
    x(v) & y(w) & (z >= 0) -> do o = v + w done
  else do o = 0 done
  end
\end{chklisting}

\Remark Signals make it possible to mimic the \zls{default} construction of 
the language \signal~\cite{signal:scp91}.
\signal's \zls{default x y} takes the value of \zls{x} when \zls{x}
is present and the value of \zls{y} when \zls{x} is absent and
\zls{y} is present.
The signal pattern \zls{x(v) | y(v)} tests the presence of ``\zls{x} or 
\zls{y}''.
\begin{chklisting}
let node default (x, y) = o where
  present
    x(v) | y(v) -> do emit o = v done
  end
\end{chklisting}
This is only a simulation of Signal's behavior since all information about 
the instants where \zls{x} and \zls{y} are present---the so-called
\emph{clock calculus} of \signal~\cite{signal:scp91}---is hidden at
run-time and not exploited by the compiler.
In particular, and unlike in the clock calculus of \signal{}, the \zelus{} 
compiler cannot determine that \zls{o} is emitted only when \zls{x} or 
\zls{y} are present.

Unlike \lustre, \lucy{} and \signal{}, \zelus{} does not currently have a 
\emph{clock calculus}.

% }-}3
% }-}2
\section{Hierarchical State Machines\label{hierstate}} %{-{2
%{-{3

\zelus{} provides hierarchical state machines that can be composed in 
parallel with regular equations or other state machines as well as 
arbitrarily nested.
State machines are essentially taken \emph{as is} from \lucy{} and 
\footnoteurl{\scadesix.}{http://www.esterel-technologies.com/products/scade-suite/}
They are compiled to data-flow equations~\cite{lucy:emsoft05b}.

In this tutorial, we first consider basic state machines where transition 
guards are limited to boolean expressions.
We then consider two important extensions.
The first is the ability to define state machines with parameterized states 
(\cref{paramstates}) and actions on transitions (\cref{transacts}).
The second is a more general form of transitions with signal matching and 
boolean expressions (\cref{patmatchsig}).

An automaton is a collection of states and transitions.
Two kinds of transitions are provided: \emph{weak} and \emph{strong}.
For each, it is possible to enter the next state by \emph{reset} or by 
\emph{history}.
An important feature of state machines in \zelus{} is that \emph{only one 
set of equations is executed during any single reaction}.

% }-}3
\subsection{Strong Preemption\label{strongpreemption}} %{-{3

The following program contains a two state automaton with strong preemption, 
it returns \zls{false} until \zls{x} becomes true and then it returns 
\zls{true} indefinitely.
\begin{chklisting}[continue,withresult]
let node strong x = o where 
  automaton
  | S1 -> do o = false unless x then S2
  | S2 -> do o = true done
  end
\end{chklisting}

Each of the two states defines a value for the \emph{shared} variable 
\zls{o}.
The keyword \zls{unless} indicates a strong transition: the automaton stays 
in the state \zls{S1} as long as \zls{x} is false, and \zls{o} is defined
by the equation \zls{o = false}, but the instant that \zls{x} becomes true,
\zls{S2} becomes active immediately, and \zls{o} is defined by the equation 
\zls{o = true}.
Thus, the following timeline holds:
\begin{chrono}{c|ccccccc}
\hline
\tt x                 & \F & \F & \T & \F & \F &  \T & $\cdots$ \\
\hline
\tt strong x           & \F & \F & \T & \T & \T &  \T & $\cdots$  \\ \hline
\end{chrono}
The guards of strong transitions are tested \emph{before} determining which 
state is active at an instant and executing its body.

% }-}3
\subsection{Weak Preemption\label{weakpreemption}} %{-{3

The following program contains a two state automaton with weak preemption, 
it returns \zls{false} at the instant that \zls{x} becomes true and then it 
returns \zls{true} indefinitely; it is like a \emph{Moore automaton}.
\begin{chklisting}[label=expect,withresult]
let node expect x = o where 
  automaton
  | S1 -> do o = false until x then S2
  | S2 -> do o = true done
  end
\end{chklisting}
This timeline of this program is shown below.
\begin{chrono}{c|ccccccc}
\hline
\tt x         & \F & \F & \T & \F & \F & \T & $\cdots$ \\ \hline
\tt expect x  & \F & \F & \F & \T & \T & \T & $\cdots$ \\ \hline
\end{chrono}

The guards of weak transitions are tested \emph{after} executing the body of 
the current active state to determine the active state at the next instant.

We now consider a two state automaton that switches between two states 
whenever the input \zls{toggle} is true.
\begin{chklisting}
let node weak_switch toggle = o where
  automaton
  | False -> do o = false until toggle then True
  | True  -> do o = true until toggle then False
  end
\end{chklisting}
For an example input stream, the timeline is:
\begin{chrono}{c|cccccccc}
\hline
\tt toggle & \F & \T & \F & \F & \T & \T & \F & $\cdots$ \\ \hline
\tt o      & \F & \F & \T & \T & \T & \F & \T & $\cdots$ \\ \hline
\end{chrono}
%
The form with strong transitions follows.
\begin{chklisting}[continue]
let node strong_switch toggle = o where
  automaton
  | False -> do o = false unless toggle then True
  | True  -> do o = true unless toggle then False
  end
\end{chklisting}
Its behavior relative to the same input sequence differs.
\begin{chrono}{c|cccccccc}
\hline
\tt toggle & \F & \T & \F & \F & \T & \T & \F & $\cdots$ \\ \hline
\tt o      & \F & \T & \T & \T & \F & \T & \T & $\cdots$ \\ \hline
\end{chrono}
In fact, for any boolean stream \zls{toggle} the following
property holds:
\begin{chklisting}[continue,skipone]
let node correct toggle =
weak_switch toggle = strong_switch (false -> pre toggle)
\end{chklisting}

\begin{figure}[t]
\centering%{-{4
\begin{tikzpicture}[zelus automata]

   % Weak automaton

   \node[state,initial] (False)                     {\zls{o = false}};
   \node[state]         (True) [right of=False]     {\zls{o = true}};

   \path
    (False) edge [weak,bend left] node {\zls{toggle}} (True)
    (True)  edge [weak,bend left] node {\zls{toggle}} (False)
    ;

   % Strong automaton

   \node[state,initial] (False) [right=1.5cm of True] {\zls{o = false}};
   \node[state]         (True)  [right of=False]      {\zls{o = true}};

   \path
    (False) edge [strong,bend left] node {\zls{toggle}} (True)
    (True)  edge [strong,bend left] node {\zls{toggle}} (False)
    ;

\end{tikzpicture}
%}-}4
\caption{Automata with weak (at left) and strong (at right) 
transitions~\label{switch-figure}}
\end{figure}
The graphical representations of these two automata are shown in
\cref{switch-figure}.
The circles on the transition arrows distinguish weak transitions from 
strong ones: they graphically separate the actions of one instant from 
another.
Since a weak transition is executed in the same instants as its source 
state, the circle is placed to separate it from its destination state.
Since a strong transition is executed in the same instants as its 
destination state, the circle is placed to separate it from its source 
state.

% Weak and strong conditions can be arbitrarily mixed as in the
% following variation of the switch automaton:
% \begin{chklisting}
% let node switch2 (toggle, stop) = o where
%   automaton
%   | False -> do o = false until toggle then True
%   | True -> do o = true until toggle then False unless stop then Stop
%   | Stop -> do o = true done
%   end
% \end{chklisting}
%
%Compared to the previous version, state \zls{True} can be strongly
%preempted when some stop condition \zls{stop} is true.

\Remark The current version of \zelus{} does not permit arbitrary 
combinations of weak and strong transitions within an automaton as in 
\lucy{} and \scadesix{}.
After much experience with automata, we think that such arbitrary mixes give 
programs that are difficult to understand.
Future versions of \zelus{} may, however, allow a constrained mix of weak 
and strong transitions.

% }-}3
\subsection{Parameterized States\label{paramstates}} %{-{3

In the examples considered so far, each automaton had a finite set of states 
and transitions.
It is also possible to define more general state machines with parameterized 
states, that is, states containing local values that are initialized on 
entry.
Parameterized states are a natural way to pass information between states 
and to reduce the number of explicitly programmed states.
Parameterized state machines lead to a style of programming that resembles 
the definition of mutually tail-recursive functions in ML.
Yet they are not compiled into mutually recursive functions but into a 
single step function with a \texttt{switch}-like construct over the active 
state.

In the following function, the automaton waits in its initial state for the 
signal \zls{e}. When \zls{e} is present, its value is bound to \zls{v} and 
the automaton transitions to the state \zls{Sustain(v)}, that is, to the 
state \zls{Sustain} with parameter \zls{x} set to \zls{v}.
\begin{chklisting}[withresult,label=await]
(* wait for e and then sustain its value indefinitely *)
let node await e = o where 
  automaton
  | Await -> do unless e(v) then Sustain(v)
  | Sustain(x) -> do emit o = x done
  end
\end{chklisting}
The formal parameter \zls{x} of the \zls{Sustain} state can be used without 
restriction in the body of the state, and the variable \zls{v} could just as
well have been an expression.

As another example, the program below uses parameterized states to count the 
occurrences of \zls{x}.
It simulates an infinite state machine with states \zls{Zero}, 
\zls{Plus(1)}, \zls{Plus(2)}, etcetera.

\begin{chklisting}[withresult]
let node count x = o where rec o = 0 -> pre o + 1

let node count_in_an_automaton x = o where
  automaton
  | Zero    -> do o = 0 until x then Plus(1)
  | Plus(v) -> do o = v until x then Plus(v+1)
  end
\end{chklisting}

% }-}3
\subsection{Modular Resets\label{resets}} %{-{3

Gérard Berry's ABRO example highlights the expressive power of parallel 
composition and preemption in Esterel. The specification 
is~\cite[\textsection 3.1]{esterel:primer99}:
\begin{quote}
Emit an output \zls{O} as soon as two inputs \zls{A} and \zls{B} have 
occurred.
Reset this behavior each time the input \zls{R} occurs.
%Await the presence of events \zls{A} and \zls{B} and emit \zls{O}
%at the exact instant that both events have been received. Reset this
%behavior every time \zls{R} is received.
\end{quote}
We will implement this example in \zelus---replacing uppercase letters by 
lowercase ones\footnote{As in \ocaml, identifiers starting with an uppercase 
letter are considered to be data type constructors and cannot be used as 
variable names.}---but generalize it slightly by considering valued events.

%The following function awaits for an event \zls{e}. When \zls{e} is present 
%with
%a value \zls{v}, the next state becomes \zls{Sustain(v)} with the parameter
%\zls{x} of state \zls{Sustain} set to \zls{v}.
%
As a first step, consider a function that implements the first part of 
the specification: it waits for occurrences of both \zls{a} and \zls{b} 
using the \zls{await} node from \cref{paramstates} and then emits the sum of 
their values.
\begin{chklisting}[withresult,include=await,label=abo]
let node abo (a, b) = o where
  present (await a)(v1) & (await b)(v2) -> do emit o = v1 + v2 done
\end{chklisting}
This first version is readily extended to the full specification by putting 
it inside an automaton state with a self-looping (weak) transition that 
resets it when \zls{r} is true.
\begin{chklisting}[withresult,continue]
let node abro (a, b, r) = o where
  automaton
  | S1 ->
       do
         present (await a)(v1) & (await b)(v2) -> do emit o = v1 + v2 done
       unless r then S1
  end
\end{chklisting}
A graphical version is shown in \cref{abro-figure}.
The transition on \zls{r} \emph{resets} the computation within the state: 
all streams in \zls{abo a b}, including those inside both \zls{await} nodes, 
restart with their initial values.
\begin{figure}[t]
\centering%{-{4
\begin{tikzpicture}[zelus automata]
   \node[state,initial] (S1) {%
    \zls{present (await a)(v1) \& (await b)(v2) -> do emit o = v1 + v2 done}};
   \path (S1) edge [weak,in=2,out=-2,loop] node[right] {\zls{r}} (S1);
\end{tikzpicture}
%}-}4
\caption{The ABRO automaton~\label{abro-figure}}
\end{figure}

\zelus{} also provides a specific \zls{reset/every} primitive as a shortcut 
for such a one-state automaton.
It combines a set of parallel equations (separated by \zls{and}s).
We could thus write:%
\begin{chklisting}[withresult,include=await]
let node strong_abro (a, b, r) = o where
  reset
    present (await a)(v1) & (await b)(v2) -> do emit o = v1 + v2 done
  every r
\end{chklisting}
Except that \zls{reset/every} is strongly preemptive; the body is reset 
before being executed at the instant the condition is true.
There is no ``weak reset'' since one need only add a unit delay for the same 
effect.
The following program implements the ABRO specification.
\begin{chklisting}[withresult,include=abo]
let node abro (a, b, r) = o where
reset
  o = abo (a, b)
every true fby r
\end{chklisting}

% It is also possible to write:

% \begin{verbatim}
% let node abro a b r = o where
%   rec automaton
%         S1 -> do automaton
%                    S1 ->
%                     do o = (except a) & (except b)
%                     until o then S2
%                  | S2 -> do o = true done
%                  end
%               unless r then S1
%       end
% \end{verbatim}

% }-}3
\subsection{Local State Definitions\label{statelocaldefs}} %{-{3

Names may be declared local to a state.
Such names can only be used inside the body of the state and in the guards 
of outgoing weak transitions.

The following program sums the integer sequence \zls{v} and emits 
false until the sum has reached some value \zls{max}. Then, it
emits \zls{true} for \zls{n} instants.
\begin{chklisting}
let node consume (max, n, v) = status where
  automaton
  | S1 ->
      let rec c = v -> pre c + v in
      do status = false
      until (c = max) then S2
  | S2 ->
      let rec c = 1 -> pre c + v in
      do status = true
      until (c = n) then S1
  end
\end{chklisting}

State \zls{S1} defines a local variable \zls{c} that is used to
compute the weak condition \zls{c = max} without introducing
any causality problems. Indeed, weak transitions only take effect
in a subsequent reaction: they define the next state, not the
current one. Moreover, there is no restriction on the kind of
expressions appearing in conditions and they may, in particular, have
some internal state. For example, the previous program can be
rewritten as:
\begin{chklisting}
let node sum v = cpt where
  rec cpt = v -> pre cpt + v

let node consume (max, n, v) = status where
  automaton
  | S1 ->
       do status = false
       until (sum v = max) then S2
  | S2 ->
       do status = true
       until (sum 1 = n) then S1
  end
\end{chklisting}

The body of a state comprises (possibly empty) sequences of local declarations 
(with \zls{local/in}), local
definitions (with \zls{let/in}), and definitions of
shared variables (with \zls{do/until}). As noted previously, weak
conditions may depend on local names and shared names.

In weak preemptions, as in the example above, transition conditions are 
evaluated \emph{after} the equations in the body have been evaluated.
The \zls{until}s in this example may not be replaced with \zls{unless}s
because in strong preemptions the transition conditions are evaluated
\emph{before} the equations in the body and may not depend on them.
Thus, writing
\begin{chklisting}[fail]
let node consume (max, n, v) = status where
  automaton
  | S1 ->
      let rec c = v -> pre c + v in
      do status = false
      unless (c = max) then S2
  | S2 ->
      let rec c = 1 -> pre c + 1 in
      do status = true
      unless (c = n) then S1
  end
\end{chklisting}
causes the compiler to emit the message:
\chklistingerr{}
%\begin{sample}
%File "tutorial.zls", line 6:
%> unless c = max then S2
%>        ^^^^^^^
%This expression may depend on itself.
%\end{sample}
The variable \zls{c} is not visible in the handler of the \zls{unless}. The
same problem occurs if \zls{c} is declared as a local variable, as in the
following program.
\begin{chklisting}[fail,withresult]
let node consume (max, n, v) = status where
  automaton
  | S1 ->
      local c in
      do c = v -> pre c + v and status = false
      unless (c = max) then S2
  | S2 ->
      local c in
      do c = v -> pre c + v and status = true
      unless (c = n) then S1
  end
\end{chklisting}

% }-}3
\subsection{States and Shared Memory\label{stateshared}} %{-{3

In the previous examples, there is no communication between the values
computed in each state.
We now consider the following simple system, due to Maraninchi and
R\'emond~\cite{Modes-SCP03}, of two running modes.
\begin{chklisting}[include=updownmodes]
let node two_states (i, min, max) = o where
  rec automaton
      | Up -> do o = last o + 1
              until (o = max) then Down
      | Down -> do o = last o - 1
                until (o = min) then Up
      end
  and init o = i
\end{chklisting}
In the \zls{Up} mode, the system continually increments
some value by \zls{1} and in the \zls{Down} mode, it decrements the same value 
by the same amount.
The transitions between these two modes are described by a two-state automaton 
whose behavior
depends on the value computed in each mode.
The system's execution diagram is
\begin{chrono}
{l|ccccccccccccc}
\hline
\tt i                 & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0   & \dots \\
\hline
\tt min               & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & \tt 0  & \tt 0 & \tt -1    & \tt 0  & \tt 0   & \dots \\
\hline
\tt max               & \tt 4  & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    &  \tt 4 & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    & \dots \\
\hline
\tt o            & \tt 1 & \tt 2 & \tt 3 & \tt 4 & \tt 3 & \tt 2 &  \tt 1 
& \tt 0  & \tt -1 & \tt 0    & \tt 1  & \tt 2   & \dots \\
\hline
\tt last o            & \tt 0 & \tt 1 & \tt 2 & \tt 3 & \tt 4 & \tt 3 &  \tt 2 
& \tt 1  & \tt 0 & \tt -1    & \tt 0  & \tt 1   & \dots \\
\hline
\tt last o + 1        & \tt 1  & \tt 2  & \tt 3  & \tt 4  &   &   & 
& & & \tt 0 & \tt 1    & \tt 2  & \dots \\
\hline
\tt last o - 1   &    &        &        &        & \tt 3 & \tt 2  & \tt 1
& \tt 0  & \tt -1 &   & & & \dots \\
\hline
\end{chrono}

As for \zls{match/with} and \zls{present}, an implicit completion mechanism 
applies so that variables like \zls{o} need not be explicitly defined in all 
automaton states.
When an equation is not given, the shared variable keeps its previous values.
In other words, an equation \zls{o = last o} is assumed.

% }-}3
\subsection{The Initial State\label{init}} %{-{3

The initial automaton state can be used to define the values of variables 
that are shared across the other states.
Such variables are considered to have a last value that can be accessed 
through the \zls{last} operator.
And, thanks to \zls{o = last o} completion, explicit definitions can be 
omitted in other states.
\begin{chklisting}
let node two_states (i, min, max) = o where
  rec automaton
      | Init ->
           do o = i until (i > 0) then Up
      | Up -> 
          do o = last o + 1
          until (o = max) then Down
      | Down -> 
          do o = last o - 1
          until (o = min) then Up
      end
\end{chklisting}

\begin{chrono}{l|cccccccccccccccc}
\hline
\tt i                 & \tt 0  & \tt 0  & \tt 0 & \tt 1  & \tt 1  & \tt 1 & \tt 1    & \tt 1  & \tt 1    &  \tt 1  & \tt 1  & \tt 1 & \tt 1    & \tt 1  & \tt 1   & \dots \\
\hline
\tt min               & \tt 0  & \tt 0  & \tt 0  & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & \tt 0  & \tt 0 & \tt -1    & \tt 0  & \tt 0   & \dots \\
\hline
\tt max               & \tt 0  & \tt 0  & \tt 0 & \tt 4  & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    &  \tt 4 & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    & \dots \\
\hline
\tt o            & \tt 0  & \tt 0  & \tt 0 & \tt 1 & \tt 2 & \tt 3 & \tt 4 & 
\tt 3 & \tt 2 &  \tt 1 & \tt 0  & \tt -1 & \tt 0    & \tt 1  & \tt 2   & 
\dots \\
\hline
\tt last o            & \tt 0  & \tt 0  & \tt 0 & \tt 0 & \tt 1 & \tt 2 & \tt 3 & \tt 4 & \tt 3 &  \tt 2 
& \tt 1  & \tt 0 & \tt -1    & \tt 0  & \tt 1   & \dots \\
\hline
\tt last o + 1     & \tt 0  & \tt 0  & \tt 0    & \tt 1  & \tt 2  & \tt 3  & 
\tt 4  &   &   & & & & \tt 0 & \tt 1    & \tt 2  & \dots \\
\hline
\tt last o - 1   & \tt 0  & \tt 0  & \tt 0 &    &        &        &        & \tt 3 & \tt 2  & \tt 1
& \tt 0  & \tt -1 &   & & & \dots \\
\hline
\end{chrono}

As the initial state \zls{Init} is only weakly preempted,
\zls{o} is necessarily initialized with the current value of
\zls{i}. Thus, \zls{last o} is well defined in the remaining
states.
Replacing weak preemption by strong preemption results in an error.
\begin{chklisting}[fail,withresult]
let node two_states (i, min, max) = o where
  rec automaton
      | Init ->
          do o = i unless (i > 0) then Up
      | Up -> 
          do o = last o + 1
          unless (o = max) then Down
      | Down -> 
          do o = last o - 1
          unless (o = min) then Up
      end
\end{chklisting}

As explained in \cref{statelocaldefs}, the guards of strong transitions may 
not depend on variables computed in the current state.
They may depend, however, on a shared memory \zls{last o}, as in:
\begin{chklisting}[skiptwo]
let node two_states (i, min, max) = o where
rec init o = i
and automaton
      | Init ->
          do o = i unless (i > 0) then Up
      | Up -> 
          do o = last o + 1
          unless (last o = max) then Down
      | Down -> 
          do o = last o - 1
          unless (last o = min) then Up
      end
\end{chklisting}
giving the same execution diagram as before:
\begin{chrono}{l|cccccccccccccccc}
\hline
\tt i                 & \tt 0  & \tt 0  & \tt 0 & \tt 1  & \tt 1  & \tt 1 & \tt 1    & \tt 1  & \tt 1    &  \tt 1  & \tt 1  & \tt 1 & \tt 1    & \tt 1  & \tt 1   & \dots \\
\hline
\tt min               & \tt 0  & \tt 0  & \tt 0  & \tt 0  & \tt 0  & \tt 0 & \tt 0    & \tt 0  & \tt 0    &  \tt 0  & \tt 0  & \tt 0 & \tt -1    & \tt 0  & \tt 0   & \dots \\
\hline
\tt max               & \tt 0  & \tt 0  & \tt 0 & \tt 4  & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    &  \tt 4 & \tt 4  & \tt 4 & \tt 4    & \tt 4  & \tt 4    & \dots \\
\hline
\tt o            & \tt 0  & \tt 0  & \tt 0 & \tt 1 & \tt 2 & \tt 3 & \tt 4 & \tt 3 & \tt 2 &  \tt 1 
& \tt 0  & \tt -1 & \tt 0    & \tt 1  & \tt 2   & \dots \\
\hline
\tt last o            & \tt 0  & \tt 0  & \tt 0 & \tt 0 & \tt 1 & \tt 2 & \tt 3 & \tt 4 & \tt 3 &  \tt 2 
& \tt 1  & \tt 0 & \tt -1    & \tt 0  & \tt 1   & \dots \\
\hline
\tt last o + 1     & \tt 0  & \tt 0  & \tt 0    & \tt 1  & \tt 2  & \tt 3  & \tt 4  &   &   & 
& & & \tt 0 & \tt 1    & \tt 2  & \dots \\
\hline
\tt last o - 1   & \tt 0  & \tt 0  & \tt 0 &    &        &        &        & \tt 3 & \tt 2  & \tt 1
& \tt 0  & \tt -1 &   & & & \dots \\
\hline
\end{chrono}

% We illustrate the feature on a boucing ball with constant speed
% whose direction only change when some collision occurs.

% \begin{verbatim}
% let node integr x0 dx = x where rec x = x0 -> pre x + dx

% let node bouncing left right x0 dx0 = x where
%   rec automaton
%         Init ->
%           do dx = dx0 then Move
%       | Move -> do until x = left or x = right then Change(-dx)
%       | Change(dir) -> do dx = dir then Move
%       end
%   and x = integr x0 dx
% \end{verbatim}
% We can make a more complicated system where the new direction is the
% result of a computation (for example, elastic collision with Newton laws).

An initial state may be parameterized if an explicit initialization clause 
is added to the automaton.
For example, the following two state automaton
starts in state \zls{Run(incr)} with \zls{incr} initialized to the first
value of \zls{i0}.
\begin{chklisting}[withresult]
let node two_states(i0, idle, run) = o where
  rec automaton
      | Run(incr) ->
          do o = 0 fby o + incr until idle() then Idle
      | Idle ->
          do until run(incr) then Run(incr)
      init Run(i0)
\end{chklisting}

% }-}3
\subsection{Resuming a State\label{resume}} %{-{3

By default, the computations within an automaton state are reset when it is 
entered.
So, for instance, the counters in the states of the example below are reset 
on every transition.
\begin{chklisting}[withresult]
let node time_restarting c = (x, y) where
  rec automaton
      | Init ->
          do x = 0 and y = 0 then S1
      | S1 ->
          do x = 0 -> pre x + 1 until c then S2
      | S2 ->
          do y = 0 -> pre y + 1 until c then S1
      end
\end{chklisting}
Giving the execution trace (where we write \f{} for \F{} and \t{} for \T):
\begin{chrono}{l|ccccccccccccccccc}
\hline
\tt c & \f & \f & \f & \f & \t & \f & \t & \f & \f & \f & \f & \t & \t & \f & \f & \f
\\ \hline
\tt x &  0 &  0 &  1 &  2 &  3 &  3 &  3 &  0 &  1 &  2 &  3 &  4 &  4 &  0 &  1 &  2
\\ \hline
\tt y &  0 &  0 &  0 &  0 &  0 &  0 &  1 &  1 &  1 &  1 &  1 &  1 &  0 &  0 &  0 &  0
\\ \hline
\end{chrono}

Note that the transition from the initial state,
\zls{do x = 0 and y = 0 then S1}, is shorthand for
\zls{do x = 0 and y = 0 until true then S1}.

It is also possible to enter a state without resetting its internal memory (as 
in the \emph{entry-by-history} of StateCharts) using the \zls{continue} 
transitions.
The modified example,
\begin{chklisting}[withresult]
let node time_sharing c = (x, y) where
  rec automaton
      | Init ->
          do x = 0 and y = 0 continue S1
      | S1 ->
          do x = 0 -> pre x + 1 until c continue S2
      | S2 ->
          do y = 0 -> pre y + 1 until c continue S1
      end
\end{chklisting}
has the execution trace:
\begin{chrono}{l|cccccccccccccccc}
\hline
\tt c & \f & \f & \f & \f & \t & \f & \t & \f & \f & \f & \f & \t & \t & \f & \f & \f
\\ \hline
\tt x &  0 &  0 &  1 &  2 &  3 &  3 &  3 &  4 &  5 &  6 &  7 &  8 &  8 &  9 & 10 & 11
\\ \hline
\tt y &  0 &  0 &  0 &  0 &  0 &  0 &  1 &  1 &  1 &  1 &  1 &  1 &  2 &  2 &  2 &  2
\\ \hline
\end{chrono}

This is a way of writing {\em activation conditions}.
It is convenient, for instance, for programming a scheduler which alternates 
between different computations, each of them having its own state.

% }-{3
\subsection{Actions on Transitions\label{transacts}} %{-{3

It is possible to perform an action on a transition.
As an example, consider programming a simple mouse controller with the 
following specification.
\begin{quote}
Return the event \zls{double} whenever two \zls{click}s are received
in less than four \zls{top}s. Emit \zls{simple} if only one click
is received within the interval.
\end{quote}
Here is one possible implementation:
\begin{chklisting}[label=counting,withresult]
let node counting e = cpt where
  rec cpt = if e then 1 -> pre cpt + 1 else 0 -> pre cpt
\end{chklisting}
\begin{chklisting}[continue,withresult]
let node controller (click, top) = (simple, double) where rec
  automaton
  | Await ->
     do simple = false and double = false until click then One
  | One ->
     do until click then do simple = false and double = true in Await
     else (counting top = 4) then
        do simple = true and double = false in Await
  end
\end{chklisting}

This program waits for the first occurrence of \zls{click}, then it enters the 
\zls{One} state and starts to count the number of \zls{top}s.
This state is exited when a second \zls{click} occurs or when the condition 
\zls{counting top = 4} becomes true.

Note that the \zls{One} state has two outgoing weak transitions (the second 
prefixed by \zls{else}.
As for the \zls{present} construct, transition guards are evaluated in order
from top to bottom.
The first to be satisfied is triggered.

\begin{chrono}{l|ccccccccccccccc}
\hline
\tt click  & \f & \t & \f & \t & \f & \t & \f & \f & \f & \f & \f & \f & \f & \f
\\ \hline
\tt top    & \t & \f & \t & \f & \t & \t & \f & \t & \t & \t & \f & \t & \t & \f
\\ \hline
\tt simple & \f & \f & \f & \f & \f & \f & \f & \f & \f & \f & \f & \t & \f & \f
\\ \hline
\tt double & \f & \f & \f & \t & \f & \f & \f & \f & \f & \f & \f & \f & \f & \f
\\ \hline
\end{chrono}

Any set of equations can be placed between the \zls{do/in} of a transition,
exactly as between a \zls{do/until} or \zls{do/unless}.

% We now come back to the example of the mouse controller whose informal
% specification is reminded below:

% \begin{quote}
% Return the event \zls{double} when two \zls{click} has been received
% in less than four \zls{top}. Emits \zls{simple} if only one click
% has been received.
% \end{quote}

% This specification is too informal and says nothing about the precise
% instant where \zls{double} or \zls{simple} must be emitted.  The
% mouse controller can be programmed as a three states automaton:


% We end with the programming of a mouse controller, a very
% classical example. Its specification is the following:
% \begin{quote}
% Return the event \zls{double} when two \zls{click} has been received
% in less than four \zls{top}. Emits \zls{simple} if only one click
% has been received.
% \end{quote}
% Here is a possible implementation:
% \begin{chklisting}
% (* counts the number of events from the last reset [res] *)
% let node counter (res, event) = count where
%   rec count = if res then 0 else x
%   and x = 0 -> if event then pre count + 1 else pre count

% let node mouse (click, top) = (single, double) where
%   rec counting = click -> if click & not (pre counting) then true
%                           else if res & pre counting then false
%                           else pre counting
%   and count = counter(res, top & counting)
%   and single = ((0 fby count) = 3) & top & not click
%   and double = (false fby counting) & click
%   and res = single or double
% \end{chklisting}

% \begin{chklisting}[label=counting]
% let node counting e = cpt where
%   rec cpt = if e then 1 -> pre cpt + 1 else 0 -> pre cpt

% let node controller (click, top) = (simple, double) where
%   automaton
%   | Await ->
%      do  simple = false and double = false
%      until click then One
%   | One ->
%      do  simple = false and double = false
%      unless click then Emit(false, true)
%      else (counting top = 4) then Emit(true, false)
%   | Emit(x1, x2) ->
%      do simple = x1 and double = x2
%      until true then Await
%   end
% \end{chklisting}

% It first awaits for the first occurrence of \zls{click}, then it
% enters in state \zls{One}, starting to count the number of
% \zls{top}. This state can be preempted strongly when a second
% \zls{click} occurs or that the condition \zls{counting top = 4} is
% true. For example when \zls{click} is true, the control immediately
% enters in state \zls{Emit(false, true)}, giving the initial values
% \zls{false} to \zls{x1} and \zls{true} to \zls{x2}. Thus, at the
% same instant, \zls{simple = false} and \zls{double = true}. Then,
% the control goes to the initial state \zls{Await} at the next
% instant.

% }-}3
\subsection{Signals and State Machines\label{statemachinesig}} %{-{3

In the automata considered until now, the conditions on transitions
have been boolean expressions. The language also provides a more general
mechanism for testing signals and accessing their values on transitions.

Using signals, we can reprogram the mouse controller of the previous section
as follows.
\begin{chklisting}[include=counting,withresult]
type event = Simple | Double

let node controller (click, top) = o where
  automaton
  | Await ->
     do until click then One
  | One ->
     do until click then do emit o = Double in Await
        else (counting top = 4) then do emit o = Simple in Await
  end
\end{chklisting}

This time no variables are defined in state \zls{Await}.
Writing \zls{emit o = x} means that \zls{o} is a signal and not
a regular stream, there is thus no need to define it in every state of the 
automaton nor to declare a last value.
The signal \zls{o} is only emitted in state \zls{Emit}.
Otherwise, it is absent.

\begin{chrono}{l|ccccccccccccccc}
\hline
\tt click  & \f & \t & \f & \t & \f & \t & \f & \f & \f & \f & \f & \f & \f & \f
\\ \hline
\tt top    & \t & \f & \t & \f & \t & \t & \f & \t & \t & \t & \f & \t & \t & \f
\\ \hline
\tt o      &    &    &    & \tt Double &  &  &  &  &  &  &  & \tt Simple &  &   
\\ \hline
\end{chrono}

Combining signals with a sum type, as is done here, has some advantages over 
the use of boolean variables in the original program.
By construction, only three values are possible for
the output: \zls{o} can only be \zls{Simple}, \zls{Double}
or absent. In the previous version, a fourth case corresponding to the
boolean value \zls{simple \& double} is possible, even though it is 
meaningless.

%}-}3
\subsection{Pattern Matching over Signals\label{patmatchsig}} %{-{3

The signal patterns introduced in \cref{signalpresence} for the \zls{present} 
construct may also be used in transition conditions to combine signals and 
access their values.

Consider, for example, the system below that has two input signals \zls{inc} 
and \zls{dec}, and that outputs a stream of integers \zls{o}.
\begin{chklisting}[withresult]
let node switch (inc, dec) = o where
  rec automaton
      | Init ->
          do o = 0
          until inc(u) then Up(u)
           else dec(u) then Down(u)
      | Up(u) ->
          do o = last o + u
          until dec(v) then Down(v)
      | Down(v) ->
          do o = last o - v
          until inc(u) then Up(u)
      end
\end{chklisting}

The condition \zls{until inc(u)} means: \emph{await the presence of
the signal \zls{low} with some value~\zls{u}, then transition to the
parameterized state \zls{Up(u)}}.

A basic preemption condition has the form \zls{e(p)} where \zls{e} is an 
expression of type \zls{t sig} and \zls{p} is a pattern of type \zls{t}.
The condition binds the variables in the pattern \zls{p} from the value of the 
signal at the instant when \zls{e} is present.
In the above example, for instance, the variable \zls{u} is introduced and 
bound over the rest of the transition.
A test for signal presence can be combined with a boolean condition.
For example,
\begin{chklisting}[withresult]
let node switch (inc, dec) = o where
  rec automaton
  | Init ->
      do o = 0
      until inc(u) then Up(u)
       else dec(u) then Down(u)
  | Up(u) ->
      let rec timeout = 0 -> pre timeout + 1 in
      do o = last o + u
      until dec(v) & (timeout > 42) then Down(v)
  | Down(v) ->
      let rec timeout = 0 -> pre timeout + 1 in
      do o = last o - v
      until inc(u) & (timeout > 42) then Up(u)
  end
\end{chklisting}
This system has the same behavior except that the presence of
\zls{dec} in the \zls{Up} state is only taken into account when the
\zls{timeout} stream has passed the value \zls{42}.

% }-}3
% }-}2
\section{Alternative Syntax for Control Structures\label{altcontrol}} %{-{2

Each of the three control structures (\zls{match/with},
\zls{automaton}, and \zls{present}) combines equations. Each branch comprises
a set of equations defining shared values. In this form, it
is not necessary to explicitly define all shared variables in every branch
since they implicitly keep their previous value or, for signals, become absent.

This syntactical convention mirrors the graphical representation of programs in 
synchronous dataflow tools (like \scade). In such tools, control structures 
naturally combine (large) sets of equations and the implicit completion of 
absent definitions is essential.

The language also provides a derived form that allows control structures
to be used in expressions. For example,
%
\begin{chklisting}
let node two x =
  match x with | true -> 1 | false -> 2
\end{chklisting}
%
can be written as a shorthand for
\begin{chklisting}
let node two x =
  let match x with
     |  true -> do o = 1 done
     | false -> do o = 2 done
     end in
  o
\end{chklisting}
%
This notation is more conventional for \ocaml{} programmers.
A similar shorthand exists for the \zls{present} and \zls{automaton}
constructs.
One can write, for instance,
\begin{chklisting}
let node toggle x = y where
  rec y =
    automaton
    | S0 -> do 0 until x then S1
    | S1 -> do 1 until x then S0
\end{chklisting}

%}-}3
%}-}2
\section{Real Time versus Logical Time\label{realvslogical}} %{-{2

We close the chapter on synchronous programming with an example real-time 
controller that tracks the passage of time using counters that then influence 
the running mode.
This example highlights the difference between the idea of logical time 
considered thus far and that of real-time.

Consider a light that blinks according to the specification:
\begin{quote}
Repeat the following behavior indefinitely:
Turn a light on for \texttt{n} seconds and then off for \texttt{m} seconds.
Allow it to be restarted at any instant.
\end{quote}

One way to start implementing this specification is to define a boolean signal 
called \zls{second} that is true at every occurrence of a second, whatever that 
may mean, and false otherwise.
We then define a node called \zls{after(n, t)} that returns \zls{true} when 
\zls{n} true values are counted on \zls{t}.
This is then instantiated twice in a node called \zls{blink\_reset} containing 
an automaton with two modes wrapped by a \zls{reset} construct.
\begin{chklisting}[label=after,label=blink_reset]
let node after(n, t) = (cpt >= n) where
  rec tick = if t then 1 else 0
  and ok = cpt >= n
  and cpt = tick -> if pre ok then n else pre cpt + tick

let node blink_reset (restart, n, m, second) = x where
 reset
   automaton
   | On  -> do x = true  until (after(n, second)) then Off
   | Off -> do x = false until (after(m, second)) then On
 every restart
\end{chklisting}

\medskip
The type signatures inferred by the compiler are:
\chklistingmsg{}

Does \zls{after(n, second)} really give a delay of \zls{n} real-time seconds?
No, for three reasons (see also~\cite{BourkeSow:SYNCHRON:2009}):
\begin{enumerate}
\item
  \zls{second} is a Boolean stream. No hypothesis is made or
  ensured by the compiler about the actual real-time duration between
  two occurrences of \emph{true} in the stream.
  It is up to the implementation to ensure that
  \zls{second} correctly approximates a real second.

\item
  The counting of instants in the expression
  \zls{after(n, t)} is only performed when the expression is active, that 
  is, it returns true when \zls{n} occurrences of the value \emph{true} have
  been \emph{observed}.
  Instantiating \zls{blink\_reset} within a branch of an \zls{automaton}
  or \zls{match} may skew the relation between logical and real time.

\item
  Even given an `accurate' \zls{second} signal and ignoring the possibility of 
  suspension at a higher-level, the expression \zls{after(n, second)} still only
  gives a delay in the interval $(n-1, n]$ seconds.
  This is because it counts ticks, not the `spaces' between ticks.
  If \zls{restart} occurs just before but not simultaneously with \zls{second},
  then the real-time delay will be less than $n$ seconds.
\end{enumerate}

In the discrete-time programs of this chapter, time is not real and absolute 
but rather logical and local.
  
%}-}2
%HEVEA\cutend
%}-}1
\chapter{Hybrid Systems Programming\label{ode-programming}} %{-{1
%{-{2

In this chapter we introduce the main novelty of \zelus{} with respect to 
standard synchronous languages: all of the previously introduced constructs, 
that is, stream equations and hierarchical automata, can be combined with 
Ordinary Differential Equations (ODEs).
As before, we only present basic examples in this document.
More advanced examples can be found on the \footnoteurl{examples web 
page.}{http://zelus.di.ens.fr/examples.html}

%}-}2
\section{Initial Value Problems\label{odeinit}} %{-{2

Consider the classic Initial Value Problem that models the temperature
of a boiler.
The evolution of the temperature $t$ is defined by an ODE and 
an initial condition:
\begin{align*}
\dot{t} &= g_0 - g_1 \cdot t \\
t(0)    &= t_0
\end{align*}
where $g_0$ and $g_1$ are constant parameters and 
$t_0$ is the initial temperature.
Instead of choosing an explicit integration scheme as in \cref{causalcheck}, we 
can now just write the ODE directly:
\begin{chklisting}[withresult]
let hybrid heater(t0, g0, g1) = t where
  rec der t = g0 -. g1 *. t init t0
\end{chklisting}

The \zls{der} keyword defines \zls{t} by a (continuous) derivative and an 
initial value.
Notice that the \zls{hybrid} keyword is used here rather than \zls{node}.
It signifies the definition of a function between continuous-time signals.
This is reflected in the type signature inferred by the compiler with its
\zls{-C->} arrow.
The \zls{C} stands for ``continuous''
Hybrid functions need special treatment for simulation with a numeric.
Discrete \zls{node}s, on the other hand, evolve in logical time, that is, as 
a sequence of instants, and may not contain any nested continuous-time 
computations.

As a second example of the new features, consider the following continuous 
definition of the sine and cosine signals whose stream approximation was 
given in \cref{localdefmut}:
\begin{chklisting}[withresult]
let hybrid sin_cos theta = (sin, cos) where
  rec der sin = theta *. cos init 0.0
  and der cos = -. theta *. sin init 1.0
\end{chklisting}

Are these definitions really all that different from those in the previous 
chapter? Yes!

\medskip
The dynamics of the boiler temperature and those of the sine and cosine 
signals are now defined by ODEs, and a numeric solver is used to approximate 
their continuous-time trajectories.
The choice of the solver is independent of the model and made outside the 
language.
Programs are defined at a higher level of abstraction, leaving the choice of 
an integration scheme to the numerical solver.
In particular, signals are not necessarily integrated using a fixed-step 
explicit scheme like that coded manually in \cref{causalcheck}.
%Continuous-time signals can be more efficiently and more precisely 
%approximated than what achieve the backward Euler method written previously.
It is possible to program models that mix discrete-time computations with 
ODEs and to simulate them together using an external solver.
%and possibly replace some of the ODEs by difference equations. Still, when 
%needed, the
%programmer can mix stream equations with ODEs.

\Remark The compiler generates sequential code that allows ODEs to be 
approximated by a numerical solver.
The current version of \zelus{} provides an interface to the
\footnoteurl{Sundials 
CVODE}{https://computation.llnl.gov/casc/sundials/main.html}~\cite{sundials:2005} 
solver and two classical variable step solvers (\texttt{ode23} and
\texttt{ode45}~\cite{DahlquistBjo08}).

\medskip
A Proportional Integral (PI) controller is a classic example of a 
continuous-time function.
Below we present two implementations: a continuous version to be 
approximated by an external numeric solver, and a discrete version using 
forward Euler integration.
\begin{chklisting}[withresult]
(* a continuous-time integrator *)
let hybrid integr(x0, x') = x where
  rec der x = x' init x0

(* a continuous-time PI controller *)
let hybrid pi(kp, ki, error) = command where
  rec command = kp *. error +. ki *. integr(0.0, error) 

let ts = 0.05

(* a explicit Euler integration *)
let node disc_integr(y0, x') = y where
  rec y = y0 -> last y +. ts *. x'

(* a discrete-time PI controller *)
let node disc_pi(kp, ki, error) = cmd where
  rec cmd = kp *. error +. ki *. disc_integr(0.0, error)
\end{chklisting}

% }-}2
\section{Mixing Discrete and Continuous Signals\label{commdisccont}} %{-{2
%{-{3
%{-{4

Care must be taken when mixing signals and systems defined in discrete 
logical time with those defined in continuous time, both to ensure that 
programs make sense and that they can be simulated effectively.
Consider, for instance, the following simple program.
\begin{chklisting}[fail]
let hybrid wrong1() = o where
  rec der x = 1.0 init 0.0
  and o = 0.0 -> pre o +. x
\end{chklisting}

\noindent
The signal \zls{x} is continuous and \zls{o} is discrete (due to the 
\zls{->} and \zls{pre} operators).
What can it mean to put them in parallel in this way?
The meaning of \zls{x} along is clear:
$\forall t \in \bR+, x(t) = t$.
It is shown in the three diagrams of \cref{wrong1interp} as a blue line that 
increases from zero with a constant slope.
Each of the diagrams shows a different interpretation for~\zls{o}:

\begin{anumerate}
\item
Since the discrete reactions can be numbered by the natural numbers and 
these numbers are a subset of the reals, we could decide to simply embed the 
discrete reactions at times $0.0$, $1.0$, $2.0$, etcetera.
The value of \zls{o} is then perfectly well defined (the red dots in the 
figure), but the mapping of reactions to continuous time is completely 
arbitrary.

\item
Since a numeric solver must inevitably approximate continuous signals over a 
sequence of discrete steps, we could decide to execute discrete equations at 
the sampling instants chosen by the solver.
This mapping of reactions is less arbitrary since it corresponds to the 
underlying discrete solver process, but the meaning of a program now depends 
on low-level details of the numerical simulation.
Changing the solver or its parameters, or adding another unrelated equation 
in parallel will likely change the value of \zls{o}.

\item
A third possibility is to consider that the process corresponding to \zls{o} 
is iterated continually, that is, as time advances infinitesimally.
Although the value of \zls{o} rapidly diverges toward infinity, it is well 
defined.
The real problem is that such programs cannot be effectively simulated using 
numeric techniques.
\end{anumerate}

\begin{figure}
\centering %{-{5
    \tikzset{timesig/.style={blue},
             ysig/.style={red},
             ezsig/.style={green},
             reaction/.style={red,thick,-latex}}
    \begin{tikzpicture}
      [yscale=.5,font=\sffamily\tiny]

    \foreach \x in {0,150,300}
    {
        \begin{scope}[xshift=\x]
            \draw[help lines] (0,-2) grid (4,10);
            \draw[->] (0,0) -- (4.25,0);
            \draw[<->] (0,-2.5) -- (0,10.5);
            \foreach \x in {0,...,4}
                \path (\x,0) node
                    [shift={(-.8mm,.5mm)},below right,help lines] {\x};
            \foreach \y in {-2,...,10}
            \draw (0,\y) node[left,help lines] {\y};

            \draw[timesig,fill] (0,0) ellipse (.05 and .10);
            \draw[timesig,thick] (0,0) -- (4,4) node[above right] {x};
        \end{scope}
    }

    % N subset R
    \begin{scope}[xshift=0]
        \draw[ysig,fill]
            (0.0, 0.0) ellipse (.05 and .10)
            (1.0, 1.0) ellipse (.05 and .10)
            (2.0, 3.0) ellipse (.05 and .10)
            (3.0, 6.0) ellipse (.05 and .10)
            (4.0,10.0) ellipse (.05 and .10);

        \draw[reaction] (0.0,-.2) -- (0.0,.5);
        \draw[reaction] (1.0,-.2) -- (1.0,.5);
        \draw[reaction] (2.0,-.2) -- (2.0,.5);
        \draw[reaction] (3.0,-.2) -- (3.0,.5);
        \draw[reaction] (4.0,-.2) -- (4.0,.5);
        
        \node at (2,-2.8)
            {\normalsize\textrm{(a) $\mathbb{N} \subseteq \mathbb{R}$}};
    \end{scope}

    % depends on solver
    \begin{scope}[xshift=150]
        \draw[ysig,fill]
            (0.0, 0.0) ellipse (.05 and .10)
            (2.0, 2.0) ellipse (.05 and .10)
            (2.5, 4.5) ellipse (.05 and .10)
            (3.8, 8.3) ellipse (.05 and .10);

        \draw[reaction] (0.0,-.2) -- (0.0,.5);
        \draw[reaction] (2.0,-.2) -- (2.0,.5);
        \draw[reaction] (2.5,-.2) -- (2.5,.5);
        \draw[reaction] (3.8,-.2) -- (3.8,.5);

        \node at (2,-2.8)
            {\normalsize\textrm{(b) depends on solver}};
    \end{scope}

    % infinitesimal steps
    \begin{scope}[xshift=300]
        \draw[ysig,fill,very thick,->]
            (0.0, 0.0) -- (0.04, 10.5);

        \draw[reaction] (0.00,-.2) -- (0.00,.5);
        \draw[reaction] (0.01,-.2) -- (0.01,.5);
        \draw[reaction] (0.02,-.2) -- (0.02,.5);
        \draw[reaction] (0.03,-.2) -- (0.03,.5);
        \draw[reaction] (0.04,-.2) -- (0.04,.5);

        \node at (2,-2.8)
            {\normalsize\textrm{(c) infinitesimal steps}};
    \end{scope}
    \end{tikzpicture} %}-}5
\caption{Possible interpretations of the \zls{wrong1} 
program.\label{wrong1interp}}
\end{figure}

\noindent
We do not consider any of these three alternatives as acceptable.
Instead, the compiler rejects \zls{wrong1} as invalid: \chklistingerr{}

Similarly, a second program,
\begin{chklisting}[fail]
let hybrid wrong2() = o where
  rec der x = o init 0.0
  and o = 0.0 -> pre o +. 1.0
\end{chklisting}
is also rejected as meaningless because \zls{o} should be the discrete-time 
signal $\forall n \in \bN, o(n) = n$ which cannot be integrated to produce 
\zls{x}.

% }-}4
\subsection{Typing Constraints.} % {-{4

The restrictions on mixing combinatorial, discrete-time, and continuous-time 
constructs are formalized as a typing system that statically accepts or 
rejects programs.

Every expression is associated to a kind $k \in \{\AnyKind, \NodeKind,
\HybridKind\}$. During typing, the compiler ensures that the following rules 
are satisfied:
\begin{enumerate}
\item
The body of a combinatorial function (see \cref{combfunc}) must be of kind 
$\AnyKind$.
The body of a stateful function (declared as a \zls{node}; see 
\cref{nodefunc}) must be of kind $\NodeKind$.
Finally, the body of a continuous-time function (declared with the 
\zls{hybrid} keyword) must be of kind $\HybridKind$. 

\item
When the parallel composition of two (sets of) equations 
``$\AndEq{E_1}{E_2}$'' is expected to have kind~$k$, then $E_1$ and $E_2$ 
must both also be of the same kind~$k$.
For instance, if $\AndEq{E_1}{E_2}$ is expected to be combinatorial ($k = 
\AnyKind$) then $E_1$ and $E_2$ must also both be combinatorial; if 
$\AndEq{E_1}{E_2}$ is discrete ($k = \NodeKind$) then both $E_1$ and $E_2$ 
must be discrete.
Finally, if $\AndEq{E_1}{E_2}$ is continuous ($k = \HybridKind$) then both 
$E_1$ and $E_2$ must be continuous.

\item
Any combinatorial equation or expression can be treated as either a discrete 
or a continuous one.
In other words, $\AnyKind$ is a subkind of both $\NodeKind$ and 
$\HybridKind$.

\end{enumerate}
Thus, all sub-expressions in the body of a combinatorial function must be of 
kind~$\AnyKind$.
All sub-expressions in the body of a node must be of kind~\AnyKind{} or of 
kind~\NodeKind.
All sub-expressions in the body of a hybrid node must be of kind~\AnyKind{} 
or of kind~\HybridKind.

In addition to these basic rules, a computation with kind \NodeKind{} can be 
placed in parallel with an expression of kind \HybridKind{} provided it is 
sampled on a \emph{discrete clock}.
We adopt the following convention:
\begin{quote}
A clock is termed \emph{discrete} if it has been declared so or if it is the 
result of a zero-crossing or a sub-sampling of a discrete clock.
Otherwise, it is termed \emph{continuous}.
\end{quote}
For example, the following function which composes an ODE and a 
discrete-time computation is correct.
The value of \zls{x} is added to that of \zls{o} at every instant where 
\zls{tick} is present.
Between \zls{tick}s, \zls{o} is unchanged.
\begin{chklisting}[withresult]
let hybrid correct(tick) = o where
  rec der x = 1.0 init 0.0
  and present tick -> do o = last o +. x done
  and init o = 0.0
\end{chklisting}
The input \zls{tick} has type \zls{zero}, the type of \emph{zero-crossing} 
events which are explained in the next section.
The interpretation of this program is sketched in \cref{correctinterp}.
The instants of activation of \zls{tick} are generated (elsewhere) by 
monitoring a continuous expression.
The value of \zls{o} (in red) is recalculated at these instants by sampling 
the value at \zls{x} and adding it onto the previous value, it is otherwise 
unchanged (that is, piecewise constant).

\begin{figure}
\centering %{-{5
    \tikzset{timesig/.style={blue},
             ysig/.style={red},
             ezsig/.style={green},
             reaction/.style={red,thick,-latex}}
    \begin{tikzpicture}
      [yscale=.5,font=\sffamily\tiny]

        \draw[help lines] (0,-2) grid (4,10);
        \draw[->] (0,0) -- (4.25,0);
        \draw[<->] (0,-2.5) -- (0,10.5);
        \foreach \x in {0,...,4}
            \path (\x,0) node
                [shift={(-.8mm,.5mm)},below right,help lines] {\x};
        \foreach \y in {-2,...,10}
        \draw (0,\y) node[left,help lines] {\y};

        \draw[timesig,fill] (0,0) ellipse (.05 and .10);
        \draw[timesig,thick] (0,0) -- (4,4) node[above right] {x};

        \draw[ezsig,thick]
            (0.0,-1.8) sin
            (1.5, 0.5) cos
            (2.5,-0.7) sin
            (2.8,-1.1) cos
            (3.4, 1.0) sin
            (4.0, 2.5);% node[above right] {e};

        \draw [ysig,very thick]
            (0.0,0.0) -- (0.86,0.0)
            (0.86,0.86) -- (3.20,0.86)
            (3.20,4.06) -- (4.0,4.06)
            ;
        \draw [ysig,fill]
            (0.86, 0.86) ellipse (.05 and .10)
            (3.20, 4.06) ellipse (.05 and .10);

        \draw[reaction] (0.86,-.2) -- (0.86,.5);
        \draw[reaction] (3.20,-.2) -- (3.20,.5);

    \end{tikzpicture} %}-}5
\caption{Interpretation of the (newly) \zls{correct} 
program.\label{correctinterp}}
\end{figure}

A formal presentation of the typing rules described in this section is 
available~\cite{lucy:lctes11}.

% }-}4
% }-}3
\subsection{Zero-crossing Events\label{zerocrossings}} %{-{3

Zero-crossings are a standard mechanism used by numeric solvers to detect 
significant events.
A solver recalculates the values of a set of \emph{zero-crossing 
expressions} at each new approximation of the continuous state of a system.
When one of the expressions changes sign between two successive 
approximations, the solver iterates to try to pinpoint the instant when the 
expression is equal to zero.

In \zelus{}, a zero-crossing expression is declared by the operator 
\zls{up(e)}.
The language runtime detects when the value of the expression \zls{e}
changes from a negative value to a positive one during integration.
The resulting events can be used to \emph{reset} ODEs as illustrated in the 
following, classic example of a bouncing ball.

Consider a ball with initial position $(x_0, y_0)$ and initial speed
$(x'_0, y'_0)$. Every time the ball hits the ground, it bounces but looses
20\% of its speed. An example trajectory is depicted 
in~\cref{bouncing-ball}.

\begin{figure}
\begin{center}
\ifhevea
\begin{rawhtml}
<img src="bouncingball.png">
\end{rawhtml}
\else
\includegraphics[width=.7\textwidth]{Fig/bouncingball}
\fi
\end{center}
\caption{The Bouncing Ball~\label{bouncing-ball}}
\end{figure}

The source program is shown below.
This version is slightly simplified compared to the
\footnoteurl{version}{http://zelus.di.ens.fr/examples.html\#ex-bouncingball} 
giving rise to \cref{bouncing-ball}: the steps are not modeled and we 
consider that the ground is at $y=0$.
We will reconsider this detail when we reprogram the example in 
\cref{hautoodes}.

\begin{chklisting}[label=gravity]
let g = 9.81
let loose = 0.8
\end{chklisting}
\begin{chklisting}[continue,withresult]
let hybrid bouncing(x0,y0,x'0,y'0) = (x,y) where
 rec der x = x' init x0
 and der x' = 0.0 init x'0
 and der y = y' init y0
 and der y' = -. g init y'0 reset up(-. y) -> -. loose *. last y'
\end{chklisting}

The ODE defining \zls{y'} is reset every time \zls{-.y} crosses zero.
At this precise instant, the initial value of \zls{y'} is \zls{-. loose *. 
last y'}.
Exactly as in \cref{syncprog}, \zls{last y'} is the value of \zls{y'} at the 
previous instant.
But the notion of previous instant for a continuous-time signal requires 
clarification.
Mathematically, at the instant of a reset, we need to distinguish the value 
of \zls{y'} \emph{just before the reset} and the new value that \zls{y'} 
takes at the instant of the reset.
As \zls{y'} is a continuous-time signal, \zls{last y'} is the \emph{left 
limit} of \zls{y'}.
It corresponds to the value of \zls{y'} computed during the integration 
process just preceding the discrete reaction that resets \zls{y'}.

Replacing \zls{last y'} by \zls{y'} leads to an error of causality.
Indeed, the current value of \zls{y'} would then depend instantaneously on 
itself.
The compiler statically rejects such programs:
\begin{chklisting}[include=gravity,fail,withresult]
let hybrid bouncing(x0,y0,x'0,y'0) = (x,y) where
 rec der x = x' init x0
 and der x' = 0.0 init x'0
 and der y = y' init y0
 and der y' = -. g init y'0 reset up(-. y) -> -. loose *. y'
\end{chklisting}

\begin{figure}
\centering %{-{4
    \begin{tikzpicture}[font=\sffamily\tiny]
    \tikzstyle{timesig}  = [blue]
    \tikzstyle{ysig}     = [red,very thick]

    \draw[fill,white,opacity=.9] (0,-1) rectangle (5,2);
    \draw[help lines] (0,-1) grid (5,2);
    \draw[->] (0,0) -- (5.25,0);
    \draw[<->] (0,-1.5) -- (0,2.5);
    \foreach \x in {0,...,5}
        \draw (\x,0) node[xshift=-1mm,below right,help lines] {\x};
    \foreach \y in {-1,...,2}
    \draw (0,\y) node[left,help lines] {\y};

    \draw[ysig]  (0,0)
        -- (1,1) (1,0)
        -- (2,1) (2,0)
        -- (3,1) (3,0)
        -- (4,1) (4,0)
        -- (5,1) (5,0)
        ;
    \draw[ysig,fill]
        (0, 0) ellipse (.05 and .05)
        (1, 0) ellipse (.05 and .05)
        (2, 0) ellipse (.05 and .05)
        (3, 0) ellipse (.05 and .05)
        (4, 0) ellipse (.05 and .05)
        (5, 0) ellipse (.05 and .05)
        ;
    \end{tikzpicture} %}-}4
\caption{Trace of the \zls{sawtooth} program.\label{sawtooth}}
\end{figure}

The sawtooth signal shown in \cref{sawtooth} is another example of an ODE 
with reset.
The signal $x: \bR^+ \mapsto \bR^+$ is defined such that $\DotNotation{x}(t) 
= 1$ and
$x(t) = 0$ if $t\in\bN$, or as a hybrid node:
\begin{chklisting}[withresult]
let hybrid sawtooth() = x where
  rec der x = 1.0 init 0.0 reset up(last x -. 1.0) -> 0.0
\end{chklisting}
%
Each time \zls{last x -. 1.0} crosses zero from a negative to positive 
value, \zls{x} is reset to zero.
Note also the use of \zls{last} to break what would otherwise be an invalid 
causality cycle.

% }-}3
\subsection{Periodic Timers\label{periodictimers}} %{-{3

A particular form of zero-crossings is provided to model timers.
A timer with phase \zls{phase} and period \zls{p} generates
an event at every instant where $t = \mathtt{phase} + n \cdot 
\mathtt{period}$ with $n \in \bN^+$.
While such timers can be expressed directly using the features described in 
the previous two sections,
\begin{chklisting}[withresult]
let hybrid timer(phase, p) = z where
  rec der t = 1.0 init -. phase reset z -> -. p
  and z = up(last t)
\end{chklisting}
\zelus{} also provides a special \zls{period} operator, which, for the 
moment at least, is restricted to timers of constant phase and period.
For example, for a timer with $\mathtt{phase} = 10.3$ and $\mathtt{p} = 20.5$
one can write \zls{period 10.3(20.5)}.
Such timers are not realized using zero-crossings, but rather by a dedicated 
and more efficient mechanism.
At every discrete transition, the minimal `next value' of all timers is 
computed to define the next integration horizon.

% }-}3
%}-}2
\section{Hierarchical Automata and ODEs\label{hautoodes}} %{-{2

We now illustrate how to combine ODEs with hierarchical automata using as an 
example, an hysteresis controller for a heater.
We will first consider the heater dynamics.
It has two modes: when \zls{active} is true, the temperature increases; when 
\zls{active} is false, it decreases.
The hysteresis controller also has two modes.
In the \zls{Idle} mode, it outputs \zls{active = false} until the 
temperature \zls{temp} reaches the lower threshold \zls{t\_min}.
The controller then stays in the \zls{Active} mode until \zls{temp} reaches 
the upper threshold \zls{t\_max}.
The complete system is obtained by composing the heater and controller in 
parallel.
Observe that the boolean signal \zls{active} only changes when a 
zero-crossing occurs.
This is a property guaranteed by the type system for all discrete 
(non-\zls{float}) data types.
%
\begin{chklisting}
let c = 1.0
let k = 1.0
let temp0 = 0.0
let t_min = 0.0
let t_max = 1.0
\end{chklisting}
\begin{chklisting}[continue]
(* an hysteresis controller for a heater: [c] and [k] are constant. *)
let hybrid heater(active) = temp where
  rec der temp = if active then c -. k *. temp else -. k *. temp init temp0

let hybrid hysteresis_controller(temp) = active where
  rec automaton
      | Idle -> do active = false until (up(t_min -. temp)) then Active
      | Active -> do active = true until (up(temp -. t_max)) then Idle
 
let hybrid main() = temp where
  rec active = hysteresis_controller(temp)
  and temp = heater(active)
\end{chklisting}

\noindent
The biggest difference between the automaton in the program above and those 
of previous programs is in the transition guards.
The transition conditions of automata in a continuous context---that is, of 
kind \HybridKind---may be either signal patterns, as described in 
\cref{patmatchsig}, or zero-crossing expressions, as in the example above.
Notably, however, they may not be boolean expressions, though boolean 
expressions may still be combined with signal patterns.
The equations within mode bodies inherit the kind of the automaton.
In this example, we simply define \zls{active} using constant expressions, 
but it would also have been possible to define signals by their derivatives 
(using \zls{der}).

As always (continuous) automata may be nested hierarchically and composed in 
parallel.
The extra structure is compiled away to generate a function that computes 
the temperature \zls{temp} in tandem with a numeric solver and that monitors 
the active zero-crossing expression.
The type system for automata~\cite{lucy:emsoft11} guarantees that mode 
changes will only occur at discrete instants, that is, in response to 
zero-crossing or timer events.

%
% It has been a matter of taste to program the hybrid function \zls{heater} 
% with
% a conditional, as well has having programmed the controller with an automaton.
% For example, one could have written equivalently:
%
% \begin{chklisting}
% let hybrid heater(active) = temps where
%   automaton
%   | Cold -> do der temp = -. k *. temp unless (not active) then Hot
%   | Hot -> do der temp = c -. k * temp unless active then Colf
%   end
% \end{chklisting}

% TODO: better integration of this text into the text above.

The ability to program with both automata and ODEs gives a restricted form 
of the \emph{hybrid automata} of Maler, Manna, and 
Pnueli~\cite{MalerMannaPnueli:hybrid92}.
In particular, hybrid automata in \zelus{} are deterministic:
\begin{enumerate}
\item When several transitions can be fired, for example because several 
conditions are true, the first one in order is taken.

\item It is not possible to associate an invariant with a state.
The current state is exited when a condition on an outgoing transition 
fires.
\end{enumerate}

We will present a slightly more complicated hybrid automata by returning to 
the bouncing ball example of \cref{zerocrossings}.
First we reprogram the vertical dynamics of the ball, this time using an 
external function, \zls{World.ground()}, to retrieve the height of the 
ground as a function of the horizontal position.
\begin{chklisting}[withresult]
(* [World.ground(x)] returns the position in [y] *)

let x_0 = 0.0
let y_0 = 8.0
let x_v = 0.72
let g = 9.81
let loose = 0.8

(* The bouncing ball *)
let atomic hybrid ball(x, y_0) = (y, y_v, z) where
  rec der y = y_v init y_0
  and der y_v = -. g init 0.0 reset z -> (-. loose *. last y_v)
  and z = up(World.ground(x) -. y)
\end{chklisting}

\noindent
We now incorporate these dynamics into an automaton with two modes.
In \zls{Bouncing}, it behaves as explained previously, but when the velocity 
of the ball becomes below a certain threshold, the system enters a 
\zls{Sliding} mode.
When \zls{Sliding}, the ball only moves in the vertical dimension, until it 
reaches the edge of a step (as determined by a \zls{World.ground\_abs()} 
function).
\begin{chklisting}[continue,withresult]
let eps = 0.01

(* The bouncing ball with two modes. *)
let hybrid ball_with_modes(x_0, y_0) = (x, y) where
  rec init y_start = y_0 
  and der x = x_v init x_0
  and automaton
      | Bouncing ->
         (* the ball is falling with a possible bound. *)
         local z, y_v in
         do (y, y_v, z) = ball(x, y_start)
         until z on (y_v < eps) then Sliding(World.ground(x))
      | Sliding(y0) ->
         (* the ball is fixed, i.e., the derivative for y is 0 *)
         do 
           y = y0 
         until up(x -. World.ground_abs x)
         then do y_start = 0.0 in Bouncing
      end
\end{chklisting}

\noindent
This example demonstrates the hierarchical instantiation of hybrid nodes, 
the use of \zls{local} variables in modes, shared variable resets on 
transition actions (\zls{...then do y\_start = 0.0 in...}) and a new 
\zls{on} operator of type \zls{zero * bool -> zero} which combines 
zero-crossing expressions and boolean conditions.
The \zls{on} operator emits an event when the zero-crossing occurs and the 
condition evaluates to \zls{true} at that instant.

Futher examples are available 
\footnoteurl{online}{http://zelus.di.ens.fr/examples.html} and in published 
papers~\cite{lucy:hscc13}.

%}-}2
%}-}1
\chapter{Compilation and Simulation\label{compilsimul}} %{-{1
%{-{2

This chapter explains the basic principles behind the compilation and 
execution of \zelus{} programs.
Understanding these details is useful for linking \zelus{} and \ocaml{} 
code, either by importing \ocaml{} values into \zelus{} or by exporting 
compiled \zelus{} code into \ocaml.

%}-}2
\section{Combinatorial Functions\label{combfuncs}} %{-{2

Combinatorial functions are defined by the form:
\begin{center}
  [ \term{let} ] [ \term{fun} ] \nterm{ident} \nterm{pattern} \term{=}
  \nterm{result-expr}
\end{center}

\medskip\noindent
They are compiled directly into \ocaml{} functions without any particular 
transformations.

% }-}2
\section{Sequential Nodes\label{seqnodes}} %{-{2

Synchronous, possibly stateful, functions are defined by the form:
\begin{center}
  [ \term{let} ] [ \term{node} ] \nterm{ident} \nterm{pattern} \term{=}
  \nterm{result-expr}
\end{center}

\medskip\noindent
They are translated as follows:
\begin{flatitemize}
\item
A record type \nterm{ident} is introduced to represent the current value of 
the node's internal state.
Such records contains fields for each unit delay and \zls{->} within the 
node, and also for every other node instantiated within it.
Values of this type are thus trees of nested records that reflect the 
structure of instantiations.

\item
A step function \nterm{ident\_step} is introduced.
Calling \nterm{ident\_step self pattern}, where \nterm{self} is the current 
state of the node (of type \nterm{ident}) and \nterm{pattern} passes the 
current value of the input, returns the current output of the node and 
directly updates the state record \nterm{self}.

\item
A reset function \nterm{ident\_reset} is also introduced.
Calling \nterm{ident\_reset self} resets the state \nterm{self} to its 
initial value.

\item
Finally, there is also an allocation function \nterm{ident\_alloc ()} which 
returns an initial state (of type \nterm{ident}).
\end{flatitemize}

% }-}2
\section{Hybrid Nodes and Interaction with a Solver\label{hybridnodes}} %{-{2

\begin{figure}[t]
\centering%{-{3
\begin{tikzpicture}[
    ->,
    semithick,
    auto,
    node distance=3.5cm,
    initial text=
]

   \node[state,initial] (D)		 {$D$};
   \node[state]         (C) [right of=D] {$C$};

   \draw[-,dotted,gray] ([yshift=-1.4cm]$(D)!0.5!(C)$) -- +(0,2.8);
   \node [baseline,above=0.7cm of D] {\emph{time stops}};
   \node [baseline,above=0.7cm of C] {\emph{tempus fugit}};

   \path
     (D) edge [loop below] node {encore} (D)
         edge [bend left,
               postaction={decorate,
                           decoration={text along path,
                                       raise=1.25ex,
                                       text align=left,
                                       text={\ \ \ [reinit]}}}] (C)
         % edge [bend left]  node [above left] {[reinit]} (C)
     (C) edge [bend left,
               postaction={decorate,
                           decoration={text along path,
                                       reverse path,
                                       raise=-2ex,
                                       text align=right,
                                       text={event\ \ \ }}}] (D)
     %(C) edge [bend left]  node [below right] {event}    (D)
         edge [loop below] node[xshift=.3cm] {approximate} (C)
     ;


\end{tikzpicture}%}-}3
\caption{Basic structure of the hybrid simulation 
algorithm\label{fig:simalgo}}
\end{figure}

Hybrid nodes are also compiled into several functions.
Their execution requires run-time support to coordinate phases of
integration by a numeric solver with the execution of discrete reactions.
Before outlining the form of compilation, we describe the principles behind 
the \emph{simulation loop} provided by the run-time.

The simulation loop of a hybrid system can be formalized as a synchronous 
function that defines four streams $\lx(n)$, $y(n)$, $z(n)$ and $t(n)$, with 
$n \in \bN$.
Here, $t(n)$ is the increasing sequence of simulation times at which the 
solver stops;\footnote{They are called \emph{major time steps} in 
\simulink.} $\lx(n)$ is the value at time $t(n) \in \bR$ of the 
\emph{continuous state variables}, that is, the variables defined by their 
derivatives in the original model; $y(n)$ is the value at time $t(n)$ of the 
model's \emph{discrete state}; and $z(n)$ signals any \emph{zero-crossings} 
occurring at instant $t(n)$.

The simulation loop function has two modes: discrete ($D$) and continuous 
($C$).
The two modes and the transitions between them are sketched 
in~\cref{fig:simalgo}.
The function begins in~$D$, where all computations that may change the 
discrete state or that have side effects are executed.
Several discrete steps may be executed without advancing the simulation 
time~$t$ in what is termed an \emph{event cascade}.
Simulation time is advanced in~$C$ where a numeric solver is invoked to 
approximate the values of ODEs within the model.
The function loops back to the~$D$ mode whenever a zero-crossing occurs 
(\cref{zerocrossings}) or a timer horizon (\cref{periodictimers}) is 
reached.
We now formalize the details of the two modes.

%\paragraph{Initialization}
%The initial discrete state $y(0)$ is a value in some
%abstract data type $S_d$ and the initial continuous state $\lx(0)$ is 
%likewise a value in some data type $S_c$.
%The solver also has an initial internal state $s(0)$ in data type $S_s$.
%We thus denote the initial state $(y, \lx, s)(0) = init$, where:
%  \[ init: S_d \times S_c \times S_s\mbox{.}\]

 %At initialization, the initial values of the discrete state, the
 %continuous state and the solver state are set. Let $y(0)$ denote the
 %initial value of the discrete state, of some abstract data type $S_d$
 %and $\lx(0)$, the initial value of the continuous state with data type
 %$S_c$ and $s(0)$ the initial internal state of the solver. If $init$
 %denotes the initial state,
 %$(y, \lx, s)(0) = init$, where:
  %\[ init: S_d \times S_c \times S_s\]

\paragraph{The Continuous Mode ($C$)}

In the continuous mode $C$, a numeric solver computes an approximation of 
the solution of the set of (active) ODEs within a model.
We represent the solver abstractly as a function $\Solve{f}{g}$ 
parameterized by two other functions $f$ and $g$:
\begin{itemize}
\item
$x'(\tau) = f(y(n), \tau, x(\tau))$ yields the derivatives of continuous 
state variables $x$ at $\tau \in \bR$,
given
the discrete states~$y(n)$ and an approximation to the continuous 
states~$x(\tau)$;
%  \[
%     f : S_d \rightarrow \bR \rightarrow S_c \rightarrow S_c
%  \]
\item
\mbox{$\mathit{upz}(\tau) = g(y(n), \tau, x(\tau))$} computes the value of 
the zero-crossing expressions~$\mathit{upz}$ given the same arguments 
as~$f$.
\end{itemize}
%  \[
%     g : S_d \rightarrow \bR \rightarrow S_c \rightarrow Z
%  \]
For a given~$f$ and~$g$, the continuous mode $C$ computes
$s$, $\lx$, $z$, and $t$ such that:
\[
(\lx, z, t, s)(n+1) = \Solve{f}{g}(s, y, \lx, t, step)(n)
\]
where
\begin{cdescription}
\item[$s(n)$]
is the internal state of the solver at instant $t(n) \in \bR$.
Calling $\Solve{f}{g}$ updates the state to $s(n+1)$.

\item[$\lx(n)$]
is the value of $x$ at instant $t(n)$, that is, $\lx(n) = x(t(n))$; $\lx$ is 
a discrete-time signal while $x$ is a continuous-time signal.

\item[$t(n+1)$]
is bounded by the horizon given to the solver $t(n) + step(n)$, that is,
\[t(n) \leq t(n+1) \leq t(n) + step(n)\]

\item[$x$]
is a solution of an ODE, parameterized by the current discrete state~$y(n)$, 
that is:
  \[\forall T \in [t(n), t(n+1) + margin]\;\;
        x(T) = \lx(n) + \int_{t(n)}^{T} f (y(n), \tau, x(\tau)))
        \,d\tau
  \]
Integration is performed on an interval strictly larger than 
\mbox{$[t(n),t(n+1)]$} to account for possible zero-crossings at instant 
$t(n+1)$.
The constant $margin$ is considered as a parameter of the solver.
%\footnote{It would also be possible to make it a
%time varying input passed to the solver. This choice
%has no consequences on the code generation problem.}
In practice, $\Solve{f}{g}$ computes a finite sample of approximated values 
on the interval $[t(n), \mbox{t(n+1)} + margin]$.
The value of $\lx(n+1)$ is \[ \lx(n+1) = x(t(n+1)) \]

\item[$z(n+1)$]
signals any zero-crossings detected at time $t(n+1)$.
It comprises $k \in \bN$ boolean elements $z(n+1)(i)$ such that:
  \[
  z(n+1)(i) = %(upz(t(n))(i) < 0) \wedge
    \begin{array}{l}
       (\forall T \in \left[t(n), t(n+1)\right) \; upz(T)(i) < 0) \\
       % Definition without positive -> negative stop
       %\begin{array}{l}
       %(\exists t_n \in \left[t(n), t(n+1)\right).\; \\
       %\hspace{1em}\phantom{\land\;}
          %(\forall T \in \left[t(n), t_n\right] \; upz(T)(i) \geq 0)
       %\\ \hspace{1em} \land\;
          %(\forall T \in \left(t_n, t(n+1)\right) \; upz(T)(i) < 0))
       %\end{array} \\
       \wedge \\
       \exists m \leq \mathit{margin}.
          (\forall T \in [t(n+1), t(n+1)+m] \; upz(T)(i) \geq 0)
    \end{array}
  \]
This definition assumes that the solver also stops whenever a zero-crossing 
expression passes through zero from positive to negative.
An event occurs with a transition to the discrete phase ($D$) when a zero-crossing
occurs or the horizon $t(n)+step(n)$ is reached:
\[\mathit{event} = z(n+1)(0) \lor \dots \lor z(n+1)(k) \lor
                         t(n+1) = t(n) + step(n)
\]
\end{cdescription}
%Finally, the solver state is local to mode $C$, that is,
%$s(n+1) = s(n)$ when $C$ is not active.
If the solver raises an error (for example, a division by zero occurs, or a 
suitable approximation cannot be found), we consider that the simulation 
fails.

\paragraph{The Discrete Mode ($D$)}
All discrete changes occur in this mode.
It is entered when an event occurs during integration.
During a discrete phase, the function $\mathit{next}$ defines $y$, $\lx$, 
$\step$, $\encore$, $z$, and $t$:
\begin{align*}
(y, \lx, step, encore%, reinit
)(n+1) & = next (y, \lx, z, t)(n) \\
z(n+1) & = false \\
t(n+1) & = t(n) \\
\end{align*}
where:
\begin{ddescription}

%\item[$\mathit{next}$] denotes the function to be executed in discrete 
%phases.
%\[
%next: S_d \rightarrow S_c \rightarrow Z \rightarrow \bR \rightarrow 
%      S_d \times S_c \times \bR \times \Bool% \times \Bool
%\]

\item[$y(n+1)$] is the new discrete state (outside of mode $D$, $y(n+1) = 
y(n)$);

\item[$\lx(n+1)$] is the new continuous state, which may be directly changed 
in the discrete mode; %; otherwise $\lx(n+1) = \lx(n)$;

\item[$\step(n+1)$] is the new step size;

\item[$\encore(n+1)$] is true if an additional discrete step must be
  performed. Function $\mathit{next}$ can decide to trigger another discrete 
  event instantaneously causing an event cascade.

\item[$t(n)$] (the simulation time) is unchanged during a discrete phase.
\end{ddescription}
%
The initial values for $y(0)$, $\lx(0)$ and $s(0)$ are given by an
initialization function \textit{init}. Finally, $\Solve{f}{g}$ may
decide to reset its internal state when the continuous state
changes. If $init\_solve(\lx(n), s(n))$ initializes the solver state, then
we have:
\begin{align*}
reinit &= (\lx(n+1) \not= \lx(n)) \\
s(n+1) &= \Ifthenelse{reinit}{init\_solve(\lx(n+1), s(n))}{s(n)} \\
\end{align*}

These definitions give a synchronous interpretation of the simulation loop,
seen as a stream function that iteratively computes the sequences $\lx$, $y$ 
and $t$ at instant $n+1$ relative to their values at instant $n$ and an
internal state. By writing $\Solve{f}{g}$, we abstract the
actual choices of the integration method and zero-crossing detection
algorithms. A more detailed description of $\Solve{f}{g}$ would be
possible (for example, as an automaton with two states: one that integrates, 
one that detects zero-crossings) but these details have no influence on
the code generation problem which is independent of such simulation
details.

Hybrid functions are defined by the form:
\begin{center}
  [ \term{let} ] [ \term{hybrid} ] \nterm{ident} \nterm{pattern} \term{=}
  \nterm{result-expr}
\end{center}

\medskip\noindent
They are compiled into six functions:
\begin{flatitemize}
\item
A record type \nterm{ident} is introduced to represent the current value of 
the function's internal state.
In addition to fields for each unit delay, \zls{->} operator, and node 
instantiation within the function body, it also contains fields for 
continuous state variables (those defined with \zls{der}) and zero-crossing 
expressions (those registered with \zls{up()}).

\item
A step function \nterm{ident\_step} is introduced.
Calling \nterm{ident\_step self pattern}, where \nterm{self} is the current 
state of the node (of type \nterm{ident}) and \nterm{pattern} passes the 
current value of the input, returns the current output of the node and 
directly updates the state record \nterm{self}.

\item
The abstract function~$f$, in the above formalization, is realized by the 
function \nterm{ident\_derivatives self pattern} that computes the current 
values of derivatives from the current state and stores them in the internal 
state \nterm{self}.

\item
The abstract function~$g$, in the above formalization, is realized by the 
function \nterm{ident\_crossings self pattern} that computes the current 
values of zero-crossing expressions and stores them in the internal state 
\nterm{self}.

\item
A reset function \nterm{ident\_reset} is also introduced.
Calling \nterm{ident\_reset self} resets the state \nterm{self} to its 
initial value.

\item
Finally, there is also an allocation function \nterm{ident\_alloc ()} which 
returns an initial state (of type \nterm{ident}).
\end{flatitemize}

% }-}2
% }-}1
\cleardoublepage
\part{Reference manual\label{refman}}
\cleardoublepage
\chapter{The language\label{language}} % {-{1
% {-{2

% Shamelessly stole from the OCaml manual
The syntax of the language is presented in BNF-like notation. Terminal
symbols are set in typewriter font (\term{like this}). Non-terminal symbols
are set in italic font (\nterm{like that}). Square brackets [ ... ] denote
optional components. Curly brackets \{ ... \} denotes zero, one, or several
repetitions of the enclosed components.

% We follow the following convention for grammatical rules. If $t$ is
% a syntactical entity, $\{\;t\;\}$ denotes the arbitrary repetition of $t$.

% }-}2
\section{Lexical conventions\label{lexical}} %{-{2

We adopt the lexical conventions of
\footnoteurl{\ocaml}{http://caml.inria.fr/pub/docs/manual-ocaml/lex.html} 
for blanks, comments, identifiers, integer
literals, floating-point literals, character literals, string
literals, and prefix and infix symbols.

\subsubsection{Keywords}
The following identifiers are reserved as keywords.

\begin{verbatim}
  as      automaton  atomic   inline  continue  disc  do    done   until
  unless  emit       present  match   period    with  end   fun    node
  hybrid  discrete   init     in      and       open  val   local  unsafe
  let     rec        where    open    fby       next  up    der    reset
  pre     type       every    true    false     or    on    last   if
  then    else       quo      mod     land      lor   lxor  lsl    lsr
  asr
\end{verbatim}
The following character sequences are also keywords.

\begin{verbatim}
        ->   >     <     =     <>     >=        )     &  ?
        +    -     *     /     ;;     <=        (     .
\end{verbatim}

%}-}2
\section{Values\label{values}} %{-{2
\subsection{Basic values\label{basicvalues}} %{-{3

\zelus{} provides the basic values of \ocaml{}---that is, integer numbers, 
floating-point numbers, characters and character strings---and with the same
conventions.

%}-}3
\subsection{Tuples, records, sum types\label{tuplesrecords}} %{-{3

\zelus{} provides the tuples of \ocaml with the same conventions. It
also provides records and sum types with constructors of arity 0.

%}-}3
\subsubsection{Functions\label{funcvalues}} %{-{3

Functions map values to other values.
They are separated into three main
categories: pure or \emph{combinatorial} functions, discrete-time stateful 
functions, and continuous-time stateful functions.

%}-}3
%}-}2
\section{Global names\label{global-names}} %{-{2
%{-{3

The naming conventions in \zelus{} are inherited from \ocaml subject to the
restrictions detailed in this section.

Names in \zelus{} fall into one of three syntactic classes:
\begin{itemize}
\item \nterm{value-name} for value names,
\item \nterm{typeconstr-name} for type constructors, and
\item \nterm{module-name} for module names.
\end{itemize}

%}-}3
\subsection{Naming values\label{namingvalues}} %{-{3

\begin{center}
\begin{tabular}{lcl}
\nterm{value-name}       & ::=    & \nterm{lowercase-ident} \\
                         & $\;\;\alt$ & \term{(} \nterm{operator-name}
                                        \term{)} \\
\nterm{operator-name}    & ::=    & \nterm{prefix-symbol} 
                           $\alt$   \nterm{infix-symbol} 
                           $\alt$   \term{*} $\alt$ \term{=} $\alt$ \term{or}
                           $\alt$   \term{\&} $\alt$ \term{||} \\
\nterm{constructor-name} & ::=    & \nterm{capitalized-ident} \\
                         & $\;\;\alt$ & \term{()} \\
\nterm{typeconstr-name}  & ::=    & \nterm{lowercase-ident} \\
\nterm{module-name}      & ::=    & \nterm{capitalized-ident}
\end{tabular}
\end{center}

The syntactic class of \nterm{lowercase-ident} is the
set of identifiers starting with a lowercase letter whereas
\nterm{capitalized-ident} is the set of of identifiers starting with a
capital letter.

% }-}3
\subsection{Referring to named values\label{refnamedvalues}} %{-{3

\begin{center}
\begin{tabular}{lcl}
\nterm{value-path}  & ::=        & \nterm{value-name} \\
                    & $\;\;\alt$ & \nterm{module-name} \term{.}
                                   \nterm{value-name} \\
\nterm{constructor} & ::=        & \nterm{constructor-name} \\
                    & $\;\;\alt$ & \nterm{module-name} \term{.}
                                   \nterm{capitalized-ident} \\
\nterm{typeconstr}  & ::=        & \nterm{typeconstr-name} \\
                    & $\;\;\alt$ & \nterm{module-name} \term{.} 
                                   \nterm{typeconstr}
\end{tabular}
\end{center}
A value can be referred to either by its name or by its name qualified with 
a module name.

% }-}3
% }-}2
\section{Types\label{typesftypes}} %{-{2

\begin{center}
\begin{tabular}{lcl}
\nterm{type} & ::=        & \term{'} \nterm{ident} \\
             & $\;\;\alt$ & \term{(} \nterm{type} \term{)} \\
             & $\;\;\alt$ & \nterm{type} \{\term{*} \nterm{type}\} \\
             & $\;\;\alt$ & \nterm{type} \nterm{typeconstr} \\
             & $\;\;\alt$ & \term{(} \nterm{type} \{\term{,}
                            \nterm{type} \}\term{)} \nterm{typeconstr} \\
             & $\;\;\alt$ & \nterm{typeconstr}
\end{tabular}
\end{center}

\begin{center}
  \begin{tabular}{lcl}
\nterm{ftype} & ::=        & \nterm{type} \term{->} \nterm{type}
  \end{tabular}
\end{center}

% The precedences are given in the following table. The constructions
% with higher precedences come first.
% \begin{center}
% \begin{tabular}{|l|l|}
% \hline
% Operator                        & Associativity \\ \hline
% {\tt sig}                       & -            \\ 
% {\tt *}                         & -             \\
% {\tt ->}                        & right         \\ \hline
% \end{tabular}
% \end{center}

% }-}2
\section{Constants\label{constants}} %{-{2

\begin{center}
\begin{tabular}{lcl}
\nterm{immediate} & ::=           & \nterm{integer-literal} \\
                  & $\;\;\alt$    & \nterm{float-literal} \\
                  & $\;\;\alt$    & \nterm{char-literal} \\
                  & $\;\;\alt$    & \nterm{string-literal} \\
                  & $\;\;\alt$    & \nterm{boolean-literal} \\
\end{tabular}
\end{center}
Constants are formed of literals from the base types (integers,
floating-point numbers, characters, character strings, and booleans).

% }-}2
\section{Patterns\label{patterns}} %{-{2

Patterns allow binding identifiers to the components of data structures.

\begin{center}
\begin{tabular}{lcl}
\nterm{pattern} & ::=        & \nterm{ident} \\
                & $\;\;\alt$ & \term{(} \nterm{pattern} \term{)} \\
                & $\;\;\alt$ & \nterm{pattern} \term{as} \nterm{ident} \\
                & $\;\;\alt$ & \term{\_} \\
                & $\;\;\alt$ & \nterm{pattern} \term{,} \nterm{pattern} 
                               \{ \term{,} \nterm{pattern} \} \\
                & $\;\;\alt$ & \term{()} \\
                & $\;\;\alt$ & \nterm{immediate} \\
                & $\;\;\alt$ & \nterm{constructor} \\
%               & $\;\;\alt$ & \nterm{constructor} \nterm{pattern} \\
                & $\;\;\alt$ & \term{\{} \nterm{label} 
                               \term{=} \nterm{pattern} \{ \term{;} 
                               \nterm{label} \term{=} \nterm{pattern}
                               \} \term{\}}
                               % \\
%       & $\alt$ & pattern \mbox{\tt when} ident \\
%                & $\;\;\alt$ & \nterm{clock} \nterm{ident} \\
%                & $\;\;\alt$ & \term{static} \nterm{ident}
\end{tabular}
\end{center}

% }-}2
\section{Signal Patterns\label{sigpatterns}} %{-{2

%\Marc{Changer la syntaxe pour la
  %suivante: \texttt{present x?(p) -> ... | \_ when c -> ...}}

Signal patterns allows for testing the presence of signals and for binding 
their values with patterns.
A boolean expressions is also considered a signal pattern (in non-continuous 
contexts).
\begin{center}
\begin{tabular}{lcl}
\nterm{signal-pattern} 
   & ::=        & \nterm{simple-expr} \\
   & $\;\;\alt$ & \nterm{simple-expression} \nterm{pattern} \\ 
   & $\;\;\alt$ & \nterm{signal-pattern} \term{on} \nterm{simple-expr} \\
   & $\;\;\alt$ & \nterm{signal-pattern} \term{\&} \nterm{signal-pattern} \\
   & $\;\;\alt$ & \nterm{signal-pattern} \term{||} \nterm{signal-pattern}
\end{tabular}
\end{center}

%}-}2
\section{Expressions\label{expressions}} %{-{2
% {-{3

\begin{center}
\begin{tabular}{lcl}
\nterm{simple-expr}
  & ::=        & \nterm{value-path} \\
  & $\;\;\alt$ & \nterm{constructor} \\
%  & $\;\;\alt$ & \nterm{constructor} \nterm{expr} \\
  & $\;\;\alt$ & \nterm{immediate} \\
  & $\;\;\alt$ & \term{(} \nterm{expr} \term{)} \\
  & $\;\;\alt$ & \term{\{} \nterm{label} \term{=} \nterm{expr}
                 \{ \term{;} \nterm{label} \term{=} \nterm{expr} \} 
                 \term{\}} \\
  & $\;\;\alt$ & \nterm{simple-expr} \term{.} \nterm{label}
\\ \\
%\nterm{multiple-matching}
%   & ::=        & \nterm{pattern-list} \term{\Minusgreater} \nterm{expr} \\
%   & $\;\;\alt$ & \nterm{pattern-list} \term{\Equalgreater} \nterm{expr} 
%\\ \\
\nterm{pattern-list}           
   & ::=        & \nterm{pattern} \{ \nterm{pattern} \}
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{lcl}
\nterm{expr}
   & ::=        & \nterm{simple-expr} \\
   & $\;\;\alt$ & \nterm{value-path} \nterm{simple-expr} \\
%   & $\;\;\alt$ & \term{\Fun} \nterm{multiple-matching} \\
%                       & $\alt$ & \Function\ simple-matching \\
   & $\;\;\alt$ & \term{\Let} [ \term{\Rec} ] \nterm{definition}
                  \{ \term{\AND} \nterm{definition} \} \term{\In} 
                  \nterm{expr} \\
   & $\;\;\alt$ & \term{\If} \nterm{expr} \term{\Then} \nterm{expr}
                  \term{\Else} \nterm{expr} \\
%                       & $\alt$ & \Match{expr}{pattern-matching} \\
   & $\;\;\alt$ & \nterm{prefix-op} \nterm{expr} \\
   & $\;\;\alt$ & \nterm{expr} \nterm{infix-op} \nterm{expr} \\
   & $\;\;\alt$ & \term{\Up} \nterm{expr} \\
   & $\;\;\alt$ & \term{\Not} \nterm{expr} \\
      & $\;\;\alt$ & \nterm{expr} \term{\Fby} \nterm{expr} \\
   & $\;\;\alt$ & \term{\Pre} \nterm{expr} \\
   & $\;\;\alt$ & \nterm{expr} \term{\Minusgreater} \nterm{expr} \\
   & $\;\;\alt$ & \term{\Last} \nterm{ident} \\
%   & $\;\;\alt$ & \term{\Run} \nterm{simple-expr} \{ \nterm{simple-expr} \} \\
   & $\;\;\alt$ & \term{match} \nterm{expr} \term{with} 
                  \nterm{match-handlers} [ \term{end} ] \\
   & $\;\;\alt$ & \term{reset} \nterm{expr} \term{every} \nterm{expr} \\ 
   & $\;\;\alt$ & \term{present} \nterm{present-handlers} [ \term{end} ]
%                       & $\alt$ & \Reset\ expr expr \{ expr\} \Every\ expr
\\ \\
\nterm{infix-op}                
& ::=        &
                \nterm{infix-symbol} 
                $\alt$ \term{*} 
                $\alt$ \term{=} 
                $\alt$ \term{or}
                $\alt$ \term{||}  
                $\alt$ \term{\&}
\\
\\
\nterm{match-handlers}
   & ::=        & [ \term{|} ] 
                  \nterm{pattern} \term{\Minusgreater} \nterm{expr}
                  \{ \term{|} 
                  \nterm{pattern} \term{\Minusgreater} \nterm{expr} \}
\\
\\
\nterm{present-handlers}
   & ::=        & [ \term{|} ] 
                  \nterm{signal-pattern} \term{->} \nterm{expr}
                  \{ \term{|}
                  \nterm{signal-pattern} \term{->} \nterm{expr} \} 
\end{tabular}
\end{center}

The precedence and associativity rules of \ocaml are adopted.
The rules for \zelus-specific primitives are, in order from highest to 
lowest precedence:
\begin{center}
{
\begin{tabular}{|l|l|} \hline
\Last                           & right         \\
\Pre                            & -             \\
function application            & -             \\
\Fby                            & left          \\
...
\Let,...                        & -             \\ 
\Minusgreater                   & right         \\ \hline
\end{tabular}
}
\end{center}

% }-}3
\subsection{Simple expressions\label{simpleexpressions}} % {-{3
\subsubsection{Constants} %{-{4

A constant expression, like \zls{1} or \zls{false}, denotes an infinite 
stream of that constant.

% }-}4
\subsubsection{Variables} %{-{4

A variable evaluates to the value bound to that variable in the current 
evaluation environment.

% }-}4
\subsubsection{Parenthesized expressions} %{-{4

The expression \term{(} \nterm{expr} \term{)} has the same value as
\nterm{expr}.

% }-}4
\subsubsection{Local definitions} %{-{4

The \term{\Let} and \term{\Let\ \Rec} constructs bind variables
locally. The expression 
\begin{center}
  \term{\Let} \nterm{definition}$_1$ \term{\AND} ... 
  \term{\AND} \nterm{definition}$_n$ \term{\In} \nterm{expr}
\end{center}
defines values to be visible in \nterm{expr}. In a \term{\Let} definition,
variables names appearing on the right of an equality are bound to their definition
in the current environment. This environment does not contains names from
the \term{\Let} definition itself.

Recursive definitions of variables are introduced by \term{\Let\ \Rec}:
\begin{center}
  \term{\Let\ \Rec} \nterm{definition}$_1$ \term{\AND} ... 
  \term{\AND} \nterm{definition}$_n$ \term{\In} \nterm{expr}
\end{center}

In a recursive definition the current environment also contains names 
defined within the \term{\Let} construction itself.

% }-}4
% }-}3
\subsection{Operators\label{operators}} % {-{3
% {-{4

The operators written \nterm{infix-op} in the grammar are applied by placing 
them between two expressions.
The operators written \nterm{prefix-op} in the grammar are applied by 
placing them in front of an expression.

The basic operators provided by \ocaml\ (from the {\tt Pervasives}
module) are imported. Scalar values imported from the
host language become stream operators that are applied
pointwise.

% }-}4
\subsubsection{Unit Delays} % {-{4

The expression \term{\Pre} \nterm{expr} denotes the delayed
stream. The $n$th value of the result is the $n-1$th
value of \nterm{expr}. The value at the first instant is undefined.

The binary operator \term{\Fby} is the initialized delay operator. The
first value of \nterm{expr}$_1$ \term{\Fby} \nterm{expr}$_2$ is the
first value of \nterm{expr}$_1$. The $n$th value is the $n-1$th
value of \nterm{expr}$_2$.

These two delay operators may only be activated on a \emph{discrete clock}. 
In \zelus{} (version 1.2) this is ensured by imposing that they appear only 
in contexts of kind $k = \NodeKind$.

% }-}4
\subsubsection{Initialization Operation} % {-{4

The expression \nterm{expr}$_1$ \term{\Minusgreater} \nterm{expr}$_2$ 
initializes a stream.
The \nterm{expr}$_i$ must be streams of the same type. The
first value of the result is the first value of
\nterm{expr}$_1$, after which the $n$th value of the result is the $n$th
value of \nterm{expr}$_2$.

The initialization operator must be activated on a \emph{discrete clock}.

% }-}4
\subsubsection{Access to a Shared State Variable} % {-{4

The expression \term{\Last} \nterm{ident} denotes the previous computed value
of the variable \nterm{ident}.

As opposed to the unit delays, \term{\Pre} and \term{\Fby}, the
operator \term{\Last} only applies to variable names and it can be activated
on both \emph{discrete} and \emph{continuous} clocks.
Nonetheless, when $\term{\Last}\; x$ appears in a continuous context,
\zelus{} (version 1.2) imposes that $x$ be a continuous state variable; in 
other words, it must be defined directly by an equation of the form 
$\term{der}\; x = e$.

% }-}4
\subsubsection{Point-wise conditional} % {-{4

The expression \term{\If} \nterm{expr}$_1$ \term{\Then}
\nterm{expr}$_2$ \term{\Else} \nterm{expr}$_3$ is the pointwise
conditional: \nterm{expr}$_1$ must be a boolean stream and
\nterm{expr}$_2$ and \nterm{expr}$_3$ must be two streams of the same
type. The type of the result is the type of \nterm{expr}$_2$.

Warning: this operator is strict, that is, at every step, both branches
are evaluated regardless of the value of the condition. The result at 
instant~$n$ is the value of \nterm{expr}$_2$ if the value of 
\nterm{expr}$_1$ is true and the value of \nterm{expr}$_3$ otherwise.

% }-}4
\subsubsection{Function application} % {-{4

The expression \nterm{value-path} \nterm{simple-expr} is the application
of the function \nterm{value-path} to the expression \nterm{simple-expr}.

% }-}4
% }-}3
\subsection{Control Structures\label{controlstructures}} % {-{3
% {-{4

The constructions \zls{reset}, \zls{match/with}, \zls{reset}, and
\zls{automaton} are control-structures which combine equations and
thus belong to the syntactic class of definitions (see
\cref{definitions}).

A derived form belonging to the syntactic class of expressions is also
provided. The derived form is useful for textual programming whereas
the original one is motivated by the graphical representation of
dataflow programs. The derived form is only syntactic sugar for the
original form.

% }-}4
\subsubsection{Pattern Matching over Expressions} % {-{4

The expression
\term{match} \nterm{expr} \term{with} 
  \nterm{pat}$_1$ \term{\Minusgreater} \nterm{expr}$_1$ \term{|} \dots 
\term{|} \nterm{pat}$_n$ \term{\Minusgreater} \nterm{expr}$_n$ \term{end}
is a short-cut for the expression:

\begin{center}
\begin{tabbing}
\term{let} \= \term{match} \nterm{expr} \term{with} \\ 
           \> \term{|} \nterm{pat}$_1$ \term{\Minusgreater} 
               \term{do} \nterm{o} \term{=} \nterm{expr}$_1$ \term{done} \\
           \> \dots \\
           \> \term{|} \nterm{pat}$_n$ \term{\Minusgreater} 
               \term{do} \nterm{o} \term{=} \nterm{expr}$_n$ \term{done} \\
           \> \term{end} \In \\
\nterm{o}
\end{tabbing}
\end{center}
provided that \nterm{o} is a fresh name.

% }-}4
\subsubsection{Modular Reset over Expressions} % {-{4

The expression \term{reset} \nterm{expr}$_1$ \term{every} \nterm{expr}$_2$
is a short-cut for
\term{let reset} \nterm{o} \term{=} \nterm{expr}$_1$ 
\term{every} \nterm{expr}$_2$ \term{in} \nterm{o},
provided that \nterm{o} is a fresh name.

% }-}4
\subsubsection{Automata} % {-{4

The expression 
\term{automaton} \nterm{state}$_1$ \term{\Minusgreater} \nterm{expr}$_1$ 
                 \nterm{trans}$_1$ 
\term{|} \dots
\term{|} \nterm{state}$_n$ \term{\Minusgreater} \nterm{expr}$_n$ 
                 \nterm{trans}$_n$ \term{end} is a short-cut
for the expression:

\begin{tabbing}
let \= \term{automaton} \\
    \> \term{|} \nterm{state}$_1$ \term{\Minusgreater} 
                 \term{do} \nterm{o} = \nterm{expr}$_1$ \nterm{trans}$_1$ \\
    \> \dots \\
    \> \term{|} \nterm{state}$_n$ \term{\Minusgreater} 
              \term{do} \nterm{o} = \nterm{expr}$_n$ \nterm{trans}$_n$ \\
    \> \term{end in} \\
\nterm{o}
\end{tabbing}
provided that \nterm{o} is a fresh name.

% }-}4
\subsubsection{Testing Presence} % {-{4

The expression
\term{present}
  \nterm{spat}$_1$ \term{\Minusgreater} \nterm{expr}$_1$ \term{|} \dots 
\term{|} \nterm{spat}$_n$ \term{\Minusgreater} \nterm{expr}$_n$ \term{end}
is a short-cut for the expression:

\begin{center}
\begin{tabbing}
\term{let} \= \term{present} \\
           \> \term{|} \nterm{spat}$_1$ \term{\Minusgreater} 
               \term{do} \nterm{o} \term{=} \nterm{expr}$_1$ \term{done} \\
           \> \dots \\
           \> \term{|} \nterm{spat}$_n$ \term{\Minusgreater} 
               \term{do} \nterm{o} \term{=} \nterm{expr}$_n$ \term{done} \\
           \> \term{end} \In \\
\nterm{o}
\end{tabbing}
\end{center}
provided that \nterm{o} is a fresh name.

% }-}4
% }-}3
% }-}2
\section{Definitions\label{langdefs}} %{-{2

\label{definitions}
\begin{center}
\begin{tabular}{lcl}
\nterm{value-definition}
   & ::=        & \term{let} \nterm{ident} \term{=} \nterm{expr} \\
   & $\;\;\alt$ & [ \term{let} ] [ \nterm{kind} ] \nterm{ident} \nterm{pattern} \term{=}
                    \nterm{result-expr}
\\ \\
\nterm{function-kind} & ::=  & \term{fun} $\alt$ \term{node}
                                              $\alt$ \term{hybrid}
\\ \\
\nterm{result-expr}
& ::=    & \nterm{expr} [ \term{\Where} [ \term{\Rec} ]
  \nterm{definition} \{ \term{\AND} \nterm{definition} \} ]
\\ \\
\nterm{definition} 
& ::=        & \nterm{pattern} \term{=} \nterm{expr} \\
   & $\;\;\alt$ & \term{init} \nterm{ident} \term{=} \nterm{expr} \\
   & $\;\;\alt$ & \term{emit} \nterm{ident} \term{=} \nterm{expr} \\
& $\;\;\alt$ & \term{match} \nterm{expr} \term{with}  
\nterm{def-match-handlers} [ \term{end} ]
\\
& $\;\;\alt$ & \term{\Reset} \nterm{definition}
               \{ \term{\AND} \nterm{definition} \} \term{\Every} \nterm{expr}
                  \\
& $\;\;\alt$ & \term{automaton} \nterm{def-automaton-handlers}
                  [ \term{end} ]
                  \\
& $\;\;\alt$ & \term{present} \nterm{def-present-handlers}
                    [ \term{else} \nterm{definition} ] [ \term{end} ]
                  \\
& $\;\;\alt$ & [ \nterm{local-definitions} ]
                    \term{do} \nterm{definition-list} \term{done}
\\ \\
\nterm{definition-list}
   & ::=        & [ \nterm{definition} \{ \term{\AND}
                  \nterm{definition} \} ]
\\ \\
\nterm{local-definitions}      
   & ::=        & \{ \term{\Let} [ \term{\Rec} ] \nterm{definition}
                  \{ \term{\AND} \nterm{definition} \} \term{\In} \}
                  \{ \term{local} \nterm{ident} \term{in} \}
\end{tabular}
\end{center}

\subsubsection{Global Value Definition}

A global definition \nterm{ident} \term{=} \nterm{expr} defines the value
of the global identifier \nterm{ident} to be equal to the value of 
\nterm{expr} in the current global environment.
The expression \nterm{expr} must be combinatorial.

\subsubsection{Global Function Definition}

A global function definition is of the form:
\begin{center}
  [ \term{let} ] [ \nterm{kind} ] \nterm{ident} \nterm{pattern} \term{=}
                    \nterm{result-expr}
\end{center}
with
\begin{center}
  \begin{tabular}{lcl}
    \nterm{function-kind} & ::=  & \term{fun} $\alt$ \term{node}
                                              $\alt$ \term{hybrid}
\end{tabular}
\end{center}

\noindent
where
\begin{itemize}
\item
\term{fun} is the kind of combinatorial functions---typically a
function imported from the host language and applied pointwise. Its
body \nterm{result-expr} must only contain combinatorial operations.
In particular, it may not invoke stateful functions like unit delays or 
integrators.

\item
\term{node} is the kind of (possibly) stateful discrete-time
functions---typically a synchronous function that must be activated
on a discrete-time scale.
Its body \nterm{result-expr} must only contain combinatorial and 
discrete-time stateful operations.
In particular, it may not invoke continuous-time operators like
integrators or zero-crossing detection.

\item
\term{hybrid} is the kind of (possibly) stateful continuous-time
functions---typically a function that contains ODEs and/or
zero-crossing detection and must be activated continuously. It may
contain all kinds of operator provided that discrete-time operations are 
activated on discrete events.
\end{itemize}

\subsubsection{Alternative Syntax for Local Definitions}

The language provides an alternate form of local definitions for returning
the results of functions. The expression:
\begin{center}
\nterm{expr} \term{\Where} [ \term{\Rec} ]
  \nterm{definition}$_1$ \term{\AND} ... \term{\AND} \nterm{definition}$_n$ 
\end{center}
has the meaning of:
\begin{center}
  \term{\Let} [ \term{\Rec} ] 
  \nterm{definition}$_1$ \term{\AND} ... \term{\AND} \nterm{definition}$_n$
  \term{\In} \nterm{expr}
\end{center}

\subsubsection{Equation}

The equation \nterm{pattern} = \nterm{expr} defines the current
value of \nterm{pattern} to be equal to the current value of \nterm{expr}.

\subsubsection{Initialization of a State Variable}

A definition \term{init} \nterm{ident} \term{=} \nterm{expr} initializes
the value of \term{\Last} \nterm{ident} with the
value of \nterm{expr}.

\subsubsection{Signal Emission}

An equation \term{\Emit} \nterm{ident} \term{=} \nterm{expr} defines
the signal \nterm{ident} to be equal to the value of \nterm{expr}. At
every instant, a signal can be absent or present. When present, it carries
a value.

\subsubsection{Pattern Matching}

\begin{center}
\begin{tabular}{lcl}
\nterm{def-match-handlers}
   & ::=        & [ \term{|} ] \nterm{def-match-handler}
                  \{ \term{|} \nterm{def-match-handler} \} 
\\ \\
\nterm{def-match-handler}
   & ::=        & \nterm{pattern} \term{\Minusgreater} \nterm{definition}
\end{tabular}
\end{center}

The construct
\term{match} \nterm{expr} \term{with} \nterm{pattern}$_1$ \term{->}
\nterm{action}$_1$ \term{|} ... \term{|} \nterm{pattern}$_n$ \term{->}
\nterm{action}$_n$ \term{end} is used to combine $n$ complementary
sub-streams. Each of these streams is on the clock defined by the
instants where the value of $e$ has the form \nterm{pattern}$_i$\ .

Each \nterm{definition} can define local and shared variables.
Shared variables are variables that may be defined and used across several 
branches and which are not bound by a \term{local} construct.

\subsubsection{Reinitialization}

The construct \term{\Reset} \nterm{definition}$_1$ \term{\AND} ...
\term{\AND} \nterm{definition}$_n$ \term{\Every} \nterm{expr} allows
for resetting the computation defined by a set of definitions. All the
defined values and expression \nterm{expr} must be on the same
clock. This construction acts as a regular multi-definition except
that the streams and automata defined in
\nterm{definition}$_1$,..., \nterm{definition}$_n$ restart with their
initial values every time the current value of {\em expr} is true. In
particular, automata appearing in \nterm{definition}$_1$,...,
\nterm{definition}$_n$ restart in their initial states.

\subsubsection{Hierarchical Automata}

\begin{center}
\begin{tabular}{lcl}
\nterm{def-automaton-handlers}
   & ::=        & [ \term{|} ] \nterm{def-automaton-handler}
                  \{ \term{|} \nterm{def-automaton-handler} \} 
\\ \\
\nterm{def-automaton-handler}
   & ::=        & \nterm{constructor} [ \nterm{pattern} ] \term{->}
                  \nterm{automaton-definition}
\\ \\
\nterm{automaton-definition}
   & ::=        & \nterm{local-definitions}
                  \term{\Do} \nterm{definition-list} \nterm{transitions}
\\ \\
\nterm{transitions}
   & ::=        & \term{\Done} \\
   & $\;\;\alt$ & \term{\Then} \nterm{state-expression} \\
   & $\;\;\alt$ & \term{\Continue} \nterm{state-expression} \\
   & $\;\;\alt$ & \term{unless} \nterm{transition}
                     \{ \term{else} \nterm{transition} \}
\\
   & $\;\;\alt$ & \term{until} \nterm{transition}
                     \{ \term{else} \nterm{transition} \}
\\ \\
\nterm{transition}
& $\;\;\alt$ & \nterm{signal-pattern} \term{\Then}
                  [ \nterm{local-definitions} \term{do} \nterm{definition-list} ]
                  \term{in} \nterm{state}
                  \\
& $\;\;\alt$ & \nterm{signal-pattern} \term{\Continue}
                  [ \nterm{local-definitions} \term{do} \nterm{definition-list} ]
                  \term{in} \nterm{state}
\\ \\
\nterm{state-expression}
   & ::=        & \nterm{constructor} \\
   & $\;\;\alt$ & \nterm{constructor} \term{(} \nterm{expr} \term{)}
\end{tabular}
\end{center}

The construction \term{automaton} \nterm{def-automaton-handler} \term{|}
... \term{|} \nterm{def-automaton-handler} \term{end} defines an
automaton. Each branch of the automaton has either the form:
\begin{center} 
  \nterm{constructor} \term{->} \nterm{automaton-definition}
\end{center}
or the form
\begin{center}
  \nterm{constructor} \nterm{pattern} \term{->} \nterm{automaton-definition}
\end{center}
where \nterm{constructor} denotes the name of the state. This state
may be parameterized by a pattern.  The first branch defines the
initial state and this state cannot be parameterized unless an 
initialization clause is given.
% TODO: add initialization clauses to the syntax

The action associated to a state has the form:
\begin{center}
  \nterm{local-definitions} \term{\Do} \nterm{definition-list} 
  \nterm{transitions}
\end{center}
It comprises a (possibly empty) sequence of local definitions to the
state, a definition list of shared variables, and a (possibly empty)
list of transitions to be tested sequentially. Transitions may
have several forms.  Writing:
\begin{center}
  \term{\Until} \nterm{transition} \{ \term{else} \nterm{transition} \}
  \end{center}
defines a {\em weak transition} which is executed within the current reaction
but at the end of it, that is, {\em after} definitions from the current state have
been executed. Transitions are all evaluated in the same instant but
sequentially: the first transition to succeed determines the target
state at the next reaction. Writing:
\begin{center}
  \term{\Unless} \nterm{transition} \{ \term{else} \nterm{transition} \}
\end{center}
defines a {\em strong transition} which is executed {\em before} the
reaction starts, that is, before definitions from the current state
have been executed. Transitions are all evaluated in the same instant
but sequentially: the first transition to succeed determines the
current active state.

A transition may reset or not the history of the state being entered.
Writing:
\begin{center}
  \nterm{signal-pattern} \term{\Then}
                  [ \nterm{local-definitions} \term{do} \nterm{definition-list} ]
                  \term{in} \nterm{state}
\end{center}
indicates that the target state is {\em entered by reset}, that is, all
streams and automata in the target state restart with their initial
values.
Writing:
\begin{center}
  \nterm{signal-pattern} \term{\Continue}
                  [ \nterm{local-definitions} \term{do} \nterm{definition-list} ]
                  \term{in} \nterm{state}
\end{center}
has the same behavior except that the target state is {\em entered by
  history}, that is, no reset occurs. For both kinds of transition
(reset or history), the condition \nterm{signal-pattern} is
tested. When it is true, \nterm{local-definitions} do
\nterm{definition-list} \term{in} \nterm{state} are executed in
the same reaction.

The language provides two transition shorthands:
\begin{enumerate}
\item
  The transition \term{\Then} \nterm{state} is shorthand for
  \term{\Until} {\tt true}
  \term{\Then} \nterm{state}
\item
  The transition \term{\Continue} \nterm{state} is shorthand
  for \term{\Until} {\tt true} \term{\Continue} \nterm{state}.
\end{enumerate}

\zelus{} (version 1.2) forbids the mixing of weak and strong conditions 
within a single automaton (not counting nested automata).
This differs from \lucy, for example, which allows for arbitrary
combinations within an automaton. We made this choice to simplify code
generation and allow for more efficient execution.
But we may lift this restriction in a future release.

\subsubsection{Testing the Presence of a Signal}

The present construct resembles the pattern-matching one.
It has the form:
\begin{center}
  \term{present} \nterm{def-present-handlers} [ \term{else} \nterm{definition} ]
  \term{end}
\end{center}
where a handler has the form:
\begin{center}
\begin{tabular}{lcl}
\nterm{def-present-handlers}
   & ::=        & [ \term{|} ] \nterm{def-present-handler}
                  \{ \term{|} \nterm{def-present-handler} \} 
\\
\nterm{def-present-handler}
   & ::=        & \nterm{signal-pattern} \term{->} \nterm{definition}
\end{tabular}
\end{center}
At every instant, signal patterns are tested sequentially and the one which 
first succeeds determines the action to execute. The optional handler:
\begin{center} 
  \term{else} \nterm{definition}
\end{center}
defines a condition which always succeed and thus gives a default action.

% }-}2
\section{Type definition\label{langtypedefs}} %{-{2

Abstract types can be defined. Their syntax is inherited from \ocaml\
and recalled here.
\begin{center}
\begin{tabular}{lcl}
\nterm{type-definition} 
  & ::=    & \term{type} \nterm{typedef} 
             \{ \term{and} \nterm{typedef} \} 
\\ \\
\nterm{typedef}
  & ::=        & [ \nterm{type-params} ] \nterm{typeconstr-name} \\
  & $\;\;\alt$ & \nterm{sum-type-def} \\
  & $\;\;\alt$ & \nterm{record-type-def} 
\\ \\
\nterm{sum-type-def}
  & ::=        & [ \term{|} ] \nterm{one-sum-def} 
                 \{ \term{|} \nterm{one-sum-def} \} 
\\ \\
\nterm{one-sum-def}     
& ::=        & \nterm{capitalized-ident}
%\\
%  & $\;\;\alt$ & \nterm{capitalized-ident} \term{of} \nterm{type} 
\\ \\
\nterm{record-type-def} 
  & ::=        & \term{\{} \nterm{label-type}
                 \{ \term{;} \nterm{label-type} \} \term{\}} 
\\ \\
\nterm{label-type}
  & ::=        & \nterm{ident} \term{:} \nterm{type} 
\\ \\
\nterm{type-params}
  & ::=        & \term{'} \nterm{ident} \\
  & $\;\;\alt$ & \term{(} \term{'} \nterm{ident} 
                 \{ \term{,} \term{'} \nterm{ident} \} \term{)}
\end{tabular}
\end{center}

% }-}2
\section{Module implementation\label{moduleimpl}} %{-{2
\begin{center}
\begin{tabular}{lcl}
\nterm{implementation}
  & ::=        & \{ \nterm{impl-phrase} [ \term{;;} ] \} 
\\ \\
\nterm{impl-phrase}
  & ::=        & \nterm{value-definition} \\ 
  & $\;\;\alt$ & \nterm{type-definition} \\
  & $\;\;\alt$ & \term{open} \nterm{module-name} 
\end{tabular}
\end{center}
A module implementation comprises a sequence of implementation
phrases. An implementation phrase either opens a module, declares a type, or 
defines a sequence of values.
\begin{itemize}
\item
The instruction \term{open} modifies the list of opened modules by adding 
the module name to the head of the list of opened modules.

\item
The type definition defines a type from the implementation
phrases following the definition.

\item
The value definition defines global values.
\end{itemize}

% }-}2
\section{Importing values\label{importing}} %{-{2

Scalar interfaces written in \ocaml\ can be imported into \zelus.
In the current implementation, a restricted subset of \ocaml\ interfaces is
considered. The syntax is the following:
\begin{center}
\begin{tabular}{lcl}
\nterm{scalar-interface}
  & :: =   & \{ \nterm{scalar-interface-phrase} [ \term{\Semisemi} ] \} 
\\ \\
\nterm{scalar-interface-phrase}
  & ::=        & \nterm{value-declaration} \\
  & $\;\;\alt$ & \nterm{type-definition}
\\ \\
\nterm{value-declaration}
  & ::=        & \term{val} \nterm{ident} \term{:} \nterm{type}
\end{tabular}
\end{center}
When a value is imported from \ocaml, it
is automatically lifted to the stream level:
\begin{itemize}
\item
A scalar value with a basic or declared type becomes an infinite stream of 
that type.

\item
A scalar functional value becomes a stream functional value
applied pointwise to its argument.
\end{itemize}

% }-}2
% }-}1
\chapter{\texttt{zeluc}\label{zeluc}} % {-{1

The \zelus{} compiler is called \texttt{zeluc}.
Given a list of options and a filename, it transforms \zelus{} source code 
into \ocaml{} source code.

\begin{verbatim}
  zeluc [option] filename
\end{verbatim}
where options are:
\begin{verbatim}
  -v             Set verbose mode
  -version       The version of the compiler
  -I <dir>       Add <dir> to the list of include directories
  -i             Print types
  -ic            Print causality types
  -where         Locate standard libray
  -stdlib <dir>  Directory for the standard library
  -nopervasives  Do not load the pervasives module
  -typeonly      Stop after typing
  -s <node>      Simulates the node <node> and generates a file <node>.ml 
                 For hybrid programs, compile with:
                 bigarray.cma unix.cma -I +sundials sundials_cvode.cma zllib.cma
  -sampling <p>  Sets the sampling period to p (float <= 1.0)
  -check <n>     Check that the simulated node returns true for n steps
  -gtk2          Use lablgtk2 interface.
                 Compile with: -I +lablgtk2 lablgtk.cma zllibgtk.cma
  -dzero         Turn on discrete zero-crossing detection
  -nocausality   (undocumented)
  -noinit        (undocumented)
  -inline <n>    Level of inlining
  -help          Display this list of options
  --help         Display this list of options
\end{verbatim}

Three kinds of arguments are accepted:
\begin{enumerate}
\item
Arguments ending in \verb-.zls- are interpreted as \zelus{} source
files. These files must contain sequences of node declarations.
The \texttt{zeluc} compiler turns \verb-.zls- files into a
compiled interface \verb-f.zci- and an \ocaml{} file \verb-f.ml-.
The \verb-.ml- file defines the corresponding transition functions for the 
values defined in the input file.

\item
Arguments ending in \verb-.zli- are interpreted as \zelus{}
interface files.
These files define type signatures for values implemented elsewhere.
The \texttt{zeluc} compiler turns \verb-.zli- files into a
compiled interface \verb-f.zci-.

\item
Arguments ending in \verb-.mli- are interpreted as \ocaml{}
interface files.
The \texttt{zeluc} compiler turns \verb-.mli- files into a
compiled interface \verb-f.zci-.
The values defined in \verb-f.mli- are considered to be a scalars.
\end{enumerate}

\subsection*{SEE ALSO}

The distribution and manual are available at \url{http://zelus.di.ens.fr}.

\subsection*{FILES}

\begin{tabular}{ll}
{\tt /usr/local/bin/zeluc}           & the compiler
\\
{\tt /usr/local/lib/zeluc} & the standard library
\end{tabular}

% }-}1
\bibliographystyle{plainurl}
\bibliography{zelus}

\end{document}
