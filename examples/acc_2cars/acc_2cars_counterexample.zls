let vfi:{v: float | v > 0.} = 0.8
let dt:{v: float | v > 0.} = 0.1
let b:{v: float | v > 0.} = 0.136
let xli:{v: float | v > 0.} = 5.
let amax:{v: float | v > 0.} = 0.05

let node exec () = 
  let rec ((xf, vf, af, xl, vl, al): 
    {(x:float)*(v:float)*(a:float)*(x2:float)*(v2:float)*(a2:float) | 
        (x < x2) &&
        
        ((((x +. ((v*.v)/.(2.*.b)) + ((1.+.(amax /. b))*.(dt*.v+.((amax*.(dt*.dt))/.2.))) +.((v*.dt)/.2.)) < (x2 +. ((v2*.v2)/.(2*.b)) +. ((v2*.dt)/.2.))) && (a = 0)) ||
        (((x +. ((v*.v)/.(2.*.b)) + ((1.+.(amax /. b))*.(dt*.v+.((amax*.(dt*.dt))/.2.))) +.((v*.dt)/.2.)) >= (x2 +. ((v2*.v2)/.(2*.b)) +. ((v2*.dt)/.2.))) && (a = -b)))       
    }) = 
    (0., vfi, 0., xli, vfi, 0.) fby 
        (let vl_next = (if (vl +. (al *. dt) < 0.) then 0. else vl +. (al *. dt)) in
            (let xl_next = (xl +. (vl_next *. dt)) in
        (let v_next = (if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt)) in
            (let x_next = (xf +. (v_next *. dt)) in
    (x_next,
     v_next,
     (if (x_next +. ((v_next *. v_next) /. (2.0*.b)) +. ((1.+.(amax /. b))*.(dt*.v_next+.((amax*.dt*.dt)/.2.))) +. (v_next *. dt /. 2.)) >=
         (xl_next +. ((vl_next *. vl_next) /. (2.0*.b)) +. (vl_next *. dt /. 2.)) then (-.b) else amax),
     xl_next,
     vl_next,
     (if (xl_next >= 6.) then (-.b) else 0.))
    ))))
    in (xf, vf, af, xl, vl, al)
	
let hybrid main () = 
	let rec trigger = (period (dt)) in
	present (trigger) -> (let (x, v, a, xl, vl, al) = exec () in (print_float x; print_string ";"; print_float xl; print_newline ())) else ()
