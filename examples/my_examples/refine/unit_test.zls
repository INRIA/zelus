(* Unit tests for refinement types *)

(* 	EXAMPLE 1: refinement variable declaration 

	- test constant numbers, defined variables, operators
*)
let pi = 3.14159
let w = 2.*.pi
let y0:float{y0 >= pi} = 4.0
let y1:float{y1 >= y0*.2.} = 10.0

(*
	EXAMPLE 2: refinement function declaration

	- multiple refinement inputs
	- 2 function body expressions
*)
let f (a : int{a > 0}) (b : int{b >= 0}) (c : int{c > 0}) : int{f_return > 0}  =  
	   let y = a + b in
	   y


(*
	EXAMPLE 3: refinement functions as a math proof

	- prove that the square of any negative number is a positive number
*)
let f2 (x:int{ x <= 0 }) : int{ y >= 0 } =
         let y = x * x in
		 y

(*
	EXAMPLE 3.1:

	- same as above but as a direct expression
*)
let f3 (x:int{x>0}) : int{ f3_return > 0} = x*x


(*
	EXAMPLE 4: refinement function with multiple constraints in return type

	- constraint on function inputs
	- logical operator on return type to concatenate constraints
*)
 let add (x : int{x > 0}) (y : int{y > 0}) : int{ add_return >= x && add_return >= y} =
		let z = x + y 
		in z 

(*
	EXAMPLE 5: refinement function with multiple body lines

	- multiple body lines
*)
let f4 (a : int{a > 0}) (b : int{b > 0}) (c : int{c > 0}) : int{f4_return >= 0}  =  
	   let z = a + b in
	   let w = b + c in
	   let y = w + z in
	   y

(*
	EXAMPLE 6: currently patological example
*)
(* let f2 (x : int{x < 0 }) : int{f2_return > 0} = 
	let y = x * x in 
	add y y *)


let node main () =
	(* let pair = (1, (2, 3)) in
	print_int (fst pair) *)
	(* let x = fst pair in
	let y = fst (snd pair) in
	let z = snd (snd pair) in
	print_string "First: "; print_int x; print_newline (); print_string "Second : "; print_int y; print_newline ();
	print_string "Third : "; print_int z; print_newline () *)
	print_int (*f (-1) 2 4*) (add (4) (3));
	(add (-1) 0)


(*
  EXAMPLE 7: usage of LTL operator in refinement definition

	- currently supported operator: box, diamond
	- LTL operator can be connected by &&, ||
*)
let add7 (x : int{x > 0}) (y : int{y > 0}) : int{ box(add7_return >= x) && diamond(add7_return >= y)} =
  x + y 

let x:int{box(x>=3) || box(x<2)} = 4


(*
  EXAMPLE 8: custom refinement type

*)
type nat = {v : int | v >= 0}

(* 
	EXAMPLE 9: treat base variable as trivially true refinement variable
*)
let x0:int = 3
let x1:int{} = 3

		(* False case: *)
let x2:int{x2>4} = 3

(* 
	EXAMPLE 10: optionally make function input and output type to be refinement 
*)
	(* - only one input is refinement *)
let add101 (x : int{x > 0}) (y : int) : int =
  x + y 
let add102 (x : int) (y : int{y > 0}) : int =
  x + y 

	(* - only return type is refinement *)
		(* True case: *)
let f101 (x : int) (y : int) : int{f101_return >= 0} =
  x*x + y*y
		(* False case: *)
let f102 (x : int) (y : int) : int{f102_return > 0} =
x + y 

	(* - both input and output type is refinement *)
let add103 (x : int{x > 0}) (y : int{y > 0}) : int{(add103_return > 0) && (add103_return = x+y)} =
  x + y 

	(* - no refinement *)
let add104 (x:int) (y:int) : int =
  x + y