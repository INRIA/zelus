(* Unit tests for refinement types *)

(* 	EXAMPLE 1: refinement variable declaration 

	- test constant numbers, defined variables, operators
*)
let pi = 3.14159
let w = 2.*.pi
let y0 : {v:float | v >= pi} = 4.0
let y1 : {v:float | v >= y0*.2.} = 10.0

(*
	EXAMPLE 2: refinement function declaration

	- multiple refinement inputs
	- 2 function body expressions
*)
let f (a : {v:int|v > 0}) (b : {v:int|v >= 0}) (c : {v:int|v > 0}) : {v:int|v > 0}  =  
	   let y = a + b in
	   y


(*
	EXAMPLE 3: refinement functions as a math proof

	- prove that the square of any negative number is a positive number
*)
let f2 (x : {v:int| v <= 0 }) : {v:int| v >= 0 } =
         let y = x * x in
		 y

(*
	EXAMPLE 3.1:

	- same as above but as a direct expression
*)
let f3 (x : {v:int|v>0}) : {v:int|v>0} = x*x


(*
	EXAMPLE 4: refinement function with multiple constraints in return type

	- constraint on function inputs
	- logical operator on return type to concatenate constraints
*)
let add (x : {v:int|v>0} ) (y : {v:int|v>0} ) : { v:int | v >= x && v >= y} =
		let z = x + y 
		in z 

(*
	EXAMPLE 5: refinement function with multiple body lines

	- multiple body lines
*)
let f4 (a : {x:int|x>0}) (b : {x:int|x>0}) (c : {x:int|x>0}) : {x : int | x >= 0}  =  
	   let z = a + b in
	   let w = b + c in
	   let y = w + z in
	   y

(*
	EXAMPLE 6: currently patological example
*)
(* let f2 (x : int{x < 0 }) : int{f2_return > 0} = 
	let y = x * x in 
	add y y *)


let node main () =
	(* let pair = (1, (2, 3)) in
	print_int (fst pair) *)
	(* let x = fst pair in
	let y = fst (snd pair) in
	let z = snd (snd pair) in
	print_string "First: "; print_int x; print_newline (); print_string "Second : "; print_int y; print_newline ();
	print_string "Third : "; print_int z; print_newline () *)
	print_int (*f (-1) 2 4*) (add (4) (3));
	(add (-1) 0)


(*
  EXAMPLE 7: usage of LTL operator in refinement definition

	- currently supported operator: box, diamond
	- LTL operator can be connected by &&, ||
*)
let add7 (x : {v:int|v>0}) (y : {v:int|v>0}) : {v:int | box(v >= x) && diamond(v >= y)} =
  x + y 

let x : {v:int | box(v>=3) || box(v<2)} = 4


(*
  EXAMPLE 8: custom refinement type

*)

type nat = {v : int | v >= 0}

(* 
	EXAMPLE 9: treat base variable as trivially true refinement variable
*)
let x0 : int = 3
(* let x1 : {} = 3 *)

		(* False case: *)
let x2 : {v:int|v>4} = 3

(* 
	EXAMPLE 10: optionally make function input and output type to be refinement 
*)
	(* - only one input is refinement *)
let add101 (x : {v:int | v>0}) (y : int) : int =
  x + y 
let add102 (x : int) (y : {v:int | v>0}) : int =
  x + y 

	(* - only return type is refinement *)
		(* True case: *)
let f101 (x : int) (y : int) : {v:int | v > 0} =
  x*x + y*y
		(* False case: *)
let f102 (x : int) (y : int) : {v:int | v > 0} =
x + y 

	(* - both input and output type is refinement *)
let add103 (x : {v:int | v > 0}) (y : {v:int | v > 0}) : {v:int | (v > 0) && (v = x+y)} =
  x + y 

	(* - no refinement *)
let add104 (x:int) (y:int) : int = x+y
let add105 (x:int) (y:int) = x+y
let add106 (x:int) y = x+y
let add107 x y = x+y



(* designed to be failed cases: 3 *)
(* 
	EXAMPLE 11: Refinement variable typing rule
*)
let y6 : {v:float | v >= 0} = -1.2