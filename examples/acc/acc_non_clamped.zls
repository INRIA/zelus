let vfi:{v: float | v > 0.} = 0.8
let dt:{v: float | v > 0.} = 0.1
let b:{v: float | v > 0.} = 0.1
let xl:{v: float | v > 0.} = 5.
(*
let node maxz (x:{w:int | true}) : {v:int | v >= 0 && ((x < 0 ) || (x = v ))} = (let ret = (if x >= 0 then x else 0) in ret)*)

let node exec () = 
  let rec ((xf, vf, af): 
    {(x:float)*(v:float)*(a:float) | (x +. ((v*. v)  /. (2.0*.b)) +. (v*. dt /. 2.) < xl) &&
		(*((a = 0.) || (x +. ((v *. v) /. (-.2. *. a)) ) < xl) && *)
		(*(v >= 0) &&*)
		((((x +. ((v *. v) /. (2.0*.b)) +. (v *. dt) +. (v *. dt /. 2.)) < xl) && (a = 0.)) (* used to be a <= 0*) ||
		 (((x +. ((v *. v) /. (2.0*.b)) +. (v *. dt) +. (v *. dt /. 2.)) >= xl) && (a = -. b)))
    }) = 
    (0., vfi, 0.) fby 
    (xf +. (vf *. dt),
     (if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt)),
     (*(vf +. (af *. dt)),*)
     (if ((xf +. (vf *. dt)) +. (((if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt)) *. (if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt))) /. (2.0*.b)) +. ((if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt)) *. dt)+. ((if (vf +. (af *. dt) < 0.) then 0. else vf +. (af *. dt)) *. dt /. 2.)) >= xl then (-.b) else 0.))
    in (xf, vf, af)
	
let hybrid main () = 
	let rec trigger = (period (dt)) in
	present (trigger) -> (let (x, v, a) = exec () in (print_float x; print_newline ())) else ()
